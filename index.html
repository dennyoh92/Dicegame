<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dice Battle - Ï£ºÏÇ¨ÏúÑ Ï†ÑÌà¨ Í≤åÏûÑ</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background: radial-gradient(ellipse at top, #eef2ff 0%, #f8fafc 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    @media (max-width: 768px) {
      body {
        padding: 0.25rem;
      }
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 2rem;
      padding: 2rem;
    }
    @media (max-width: 1024px) {
      .container { 
        grid-template-columns: 1fr;
        padding: 0.75rem;
        gap: 0.75rem;
      }
    }
    @media (max-width: 768px) {
      .container {
        padding: 0.25rem;
        gap: 0.5rem;
      }
    }
    .main-game {
      background: rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(12px);
      border-radius: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 20px 25px -5px rgba(99, 102, 241, 0.1);
      padding: 2rem;
      min-height: 750px;
      position: relative;
      overflow: hidden;
    }
    @media (max-width: 768px) {
      .main-game {
        padding: 0.75rem;
        border-radius: 1rem;
        min-height: auto;
      }
    }
    .bg-decoration {
      position: absolute;
      border-radius: 50%;
      filter: blur(60px);
      pointer-events: none;
    }
    .bg-1 { top: 0; left: 0; width: 256px; height: 256px; background: rgba(129, 140, 248, 0.1); transform: translate(-50%, -50%); }
    .bg-2 { bottom: 0; right: 0; width: 384px; height: 384px; background: rgba(249, 168, 212, 0.1); transform: translate(33%, 33%); }
    .title {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 2.5rem;
      font-weight: bold;
      color: #1e293b;
    }
    @media (max-width: 768px) {
      .title {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }
    }
    .subtitle {
      text-align: center;
      font-size: 0.875rem;
      color: #64748b;
      margin-bottom: 1rem;
    }
    .stage-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .stage-badge {
      background: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      font-weight: bold;
    }
    .gold-display {
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: 0 2px 4px rgba(251, 191, 36, 0.3);
    }
    .gold-icon {
      font-size: 1rem;
    }
    .monster-section {
      margin-bottom: 1rem;
    }
    .monster-container {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    @media (max-width: 768px) {
      .monster-container {
        padding: 0.75rem;
        min-height: 200px;
      }
    }
    .monster-body {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1rem;
      transition: transform 0.3s ease;
      overflow: visible;
      width: 100%;
      max-width: 100%;
    }
    @media (max-width: 768px) {
      .monster-body {
        margin-bottom: 0.5rem;
      }
    }
    .monster-image {
      width: 200px;
      height: 200px;
      object-fit: contain;
    }
    .monster-image-sprite {
      width: 200px;
      height: 200px;
      background-repeat: no-repeat;
    }
    @media (max-width: 768px) {
      .monster-image {
        width: 140px;
        height: 140px;
      }
      .monster-image-sprite {
        width: 140px;
        height: 140px;
      }
    }
    .monster-body.attacking {
      animation: monsterAttack 0.5s ease-out;
    }
    @keyframes monsterAttack {
      0% { transform: translateX(0) scale(1); }
      50% { transform: translateX(30px) scale(1.1); }
      100% { transform: translateX(0) scale(1); }
    }
    .dice-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
      position: relative;
    }
    @media (max-width: 768px) {
      .dice-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.75rem;
        max-width: 220px;
        margin-left: auto;
        margin-right: auto;
      }
    }
    .dice-container.attacking {
      animation: playerAttack 0.6s ease-out;
    }
    @keyframes playerAttack {
      0% { transform: translateY(0); }
      30% { transform: translateY(-20px) scale(1.1); }
      60% { transform: translateY(-10px) scale(1.05); }
      100% { transform: translateY(0) scale(1); }
    }
    .attack-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    .attack-flash {
      position: absolute;
      inset: -20px;
      background: radial-gradient(circle, rgba(239, 68, 68, 0.3) 0%, transparent 70%);
      border-radius: 50%;
      animation: attackFlash 0.3s ease-out;
      opacity: 0;
    }
    @keyframes attackFlash {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }
    .monster-attack-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200%;
      height: 200%;
      pointer-events: none;
      z-index: 10;
    }
    .monster-attack-flash {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, rgba(245, 158, 11, 0.4) 0%, transparent 70%);
      border-radius: 50%;
      animation: monsterAttackFlash 0.4s ease-out;
      opacity: 0;
    }
    @keyframes monsterAttackFlash {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.3); opacity: 0; }
    }
    .monster-slime {
      width: 180px; height: 140px;
      position: relative;
      animation: slimeBounce 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes slimeBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-10px) scale(1.05); }
    }
    .monster-slime::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #bef264 0%, #84cc16 50%, #65a30d 100%);
      border-radius: 60% 60% 50% 50% / 70% 70% 30% 30%;
      box-shadow: 
        0 15px 30px rgba(34, 197, 94, 0.4),
        inset 0 -20px 40px rgba(22, 163, 74, 0.3),
        inset 0 20px 20px rgba(254, 255, 255, 0.2);
    }
    .monster-slime::after {
      content: '';
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 100px;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
      border-radius: 50%;
    }
    .slime-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 2;
    }
    .slime-eye {
      width: 24px;
      height: 32px;
      background: white;
      border-radius: 50%;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .slime-eye::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 6px;
      width: 12px;
      height: 16px;
      background: #1e293b;
      border-radius: 50%;
    }
    .slime-mouth {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      border: 3px solid #15803d;
      border-top: none;
      border-radius: 0 0 50% 50%;
    }
    .slime-bubbles {
      position: absolute;
      bottom: -10px;
      right: 20px;
      width: 12px;
      height: 12px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: bubbleFloat 3s ease-in-out infinite;
    }
    .slime-bubbles::after {
      content: '';
      position: absolute;
      bottom: 15px;
      right: 5px;
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: bubbleFloat 3s ease-in-out infinite 0.5s;
    }
    @keyframes bubbleFloat {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
      50% { transform: translateY(-15px) scale(1.2); opacity: 0.3; }
    }
    
    .monster-goblin {
      width: 160px; height: 200px;
      position: relative;
      animation: goblinSway 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes goblinSway {
      0%, 100% { transform: rotate(-2deg); }
      50% { transform: rotate(2deg); }
    }
    .monster-goblin::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 40%, #16a34a 100%);
      border-radius: 40% 50% 35% 45% / 50% 55% 40% 45%;
      box-shadow: 
        0 20px 40px rgba(34, 197, 94, 0.3),
        inset 0 -30px 50px rgba(21, 128, 61, 0.4),
        inset 0 10px 20px rgba(255, 255, 255, 0.15);
    }
    .goblin-ears {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 60px;
      z-index: 1;
    }
    .goblin-ear-left {
      position: absolute;
      left: 20px;
      top: 0;
      width: 32px;
      height: 42px;
      background: linear-gradient(135deg, #16a34a, #15803d);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-15deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .goblin-ear-left::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 10px;
      width: 14px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(34, 197, 94, 0.4), transparent);
      border-radius: 50%;
    }
    .goblin-ear-right {
      position: absolute;
      right: 20px;
      top: 0;
      width: 32px;
      height: 42px;
      background: linear-gradient(225deg, #16a34a, #15803d);
      border-radius: 0 50% 50% 50%;
      transform: rotate(15deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .goblin-ear-right::after {
      content: '';
      position: absolute;
      top: 12px;
      right: 10px;
      width: 14px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(34, 197, 94, 0.4), transparent);
      border-radius: 50%;
    }
    .goblin-eyes {
      position: absolute;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 2;
    }
    .goblin-eye {
      width: 32px;
      height: 36px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      border: 4px solid #ca8a04;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 0 15px rgba(250, 204, 21, 0.6);
      position: relative;
    }
    .goblin-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      width: 12px;
      height: 14px;
      background: #dc2626;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    .goblin-eye::after {
      content: '';
      position: absolute;
      top: 10px;
      left: 10px;
      width: 6px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
    }
    .goblin-nose {
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 24px;
      height: 22px;
      background: linear-gradient(to bottom, #22c55e, #16a34a);
      border-radius: 50%;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .goblin-mouth {
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 35px;
      background: linear-gradient(to top, #991b1b, #7f1d1d);
      border-radius: 0 0 50% 50% / 0 0 100% 100%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.6),
        0 2px 4px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-around;
      padding-top: 6px;
    }
    .goblin-tooth {
      width: 6px;
      height: 10px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    
    .monster-orc {
      width: 200px; height: 220px;
      position: relative;
      animation: orcBreathe 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes orcBreathe {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    .monster-orc::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #10b981 0%, #059669 50%, #047857 100%);
      border-radius: 30% 40% 25% 35% / 45% 50% 40% 45%;
      box-shadow: 
        0 25px 50px rgba(5, 150, 105, 0.4),
        inset 0 -40px 60px rgba(4, 120, 87, 0.5),
        inset 0 15px 30px rgba(255, 255, 255, 0.1);
    }
    .orc-ears {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 50px;
      z-index: 1;
    }
    .orc-ear-left {
      position: absolute;
      left: 25px;
      top: 0;
      width: 28px;
      height: 42px;
      background: linear-gradient(135deg, #047857, #065f46);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-15deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .orc-ear-left::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 10px;
      width: 12px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(5, 150, 105, 0.3), transparent);
      border-radius: 50%;
    }
    .orc-ear-right {
      position: absolute;
      right: 25px;
      top: 0;
      width: 28px;
      height: 42px;
      background: linear-gradient(225deg, #047857, #065f46);
      border-radius: 0 50% 50% 50%;
      transform: rotate(15deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .orc-ear-right::after {
      content: '';
      position: absolute;
      top: 12px;
      right: 10px;
      width: 12px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(5, 150, 105, 0.3), transparent);
      border-radius: 50%;
    }
    .orc-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 45px;
      z-index: 2;
    }
    .orc-eye {
      width: 38px;
      height: 28px;
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border-radius: 50%;
      border: 5px solid #065f46;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.35),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .orc-eye::before {
      content: '';
      position: absolute;
      top: 5px;
      left: 7px;
      width: 14px;
      height: 14px;
      background: #b91c1c;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }
    .orc-eye::after {
      content: '';
      position: absolute;
      top: 6px;
      left: 8px;
      width: 6px;
      height: 6px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
    }
    .orc-nose {
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 28px;
      background: linear-gradient(to bottom, #047857, #065f46);
      border-radius: 50%;
      box-shadow: 
        inset 0 5px 10px rgba(0, 0, 0, 0.6),
        0 3px 6px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    .orc-tusks {
      position: absolute;
      top: 161px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 3;
    }
    .orc-tusk {
      width: 13px;
      height: 30px;
      background: linear-gradient(to bottom, #fef3c7, #fde68a);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        0 3px 6px rgba(0, 0, 0, 0.4),
        inset 0 -2px 4px rgba(217, 119, 6, 0.3);
    }
    .orc-tusk-left { transform: rotate(164deg); }
    .orc-tusk-right { transform: rotate(196deg); }
    .orc-mouth {
      position: absolute;
      bottom: 35px;
      left: 50%;
      transform: translateX(-50%);
      width: 65px;
      height: 24px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.7),
        0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    
    .monster-dragon {
      width: 220px; height: 240px;
      position: relative;
      animation: dragonFloat 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes dragonFloat {
      0%, 100% { transform: translateY(0) rotate(-2deg); }
      50% { transform: translateY(-8px) rotate(2deg); }
    }
    .monster-dragon::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #f87171 0%, #ef4444 30%, #dc2626 70%, #991b1b 100%);
      border-radius: 45% 50% 35% 40% / 55% 60% 25% 35%;
      box-shadow: 
        0 30px 60px rgba(239, 68, 68, 0.5),
        inset 0 -50px 80px rgba(153, 27, 27, 0.6),
        inset 0 20px 40px rgba(255, 255, 255, 0.15);
    }
    .dragon-horns {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 60px;
      z-index: 2;
    }
    .dragon-horn-left {
      position: absolute;
      left: 50px;
      top: 0;
      width: 22px;
      height: 52px;
      background: linear-gradient(135deg, #525252, #404040);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-18deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .dragon-horn-left::after {
      content: '';
      position: absolute;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    .dragon-horn-right {
      position: absolute;
      right: 50px;
      top: 0;
      width: 22px;
      height: 52px;
      background: linear-gradient(225deg, #525252, #404040);
      border-radius: 0 50% 50% 50%;
      transform: rotate(18deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .dragon-horn-right::after {
      content: '';
      position: absolute;
      top: 5px;
      right: 5px;
      width: 10px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    .dragon-eyes {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 50px;
      z-index: 3;
    }
    .dragon-eye {
      width: 32px;
      height: 40px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 25px rgba(250, 204, 21, 0.9),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .dragon-eye::before {
      content: '';
      position: absolute;
      top: 7px;
      left: 7px;
      width: 12px;
      height: 16px;
      background: #000;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .dragon-eye::after {
      content: '';
      position: absolute;
      top: 9px;
      left: 9px;
      width: 5px;
      height: 7px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
    }
    .dragon-snout {
      position: absolute;
      top: 105px;
      left: 50%;
      transform: translateX(-50%);
      width: 42px;
      height: 30px;
      background: linear-gradient(to bottom, #dc2626, #b91c1c);
      border-radius: 50%;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    .dragon-nostrils {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      gap: 14px;
      z-index: 3;
    }
    .dragon-nostril {
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }
    .dragon-mouth {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 20px;
      background: linear-gradient(to top, #f97316, #ea580c);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.6),
        0 0 15px rgba(249, 115, 22, 0.6);
      animation: fireGlow 1.5s ease-in-out infinite;
      z-index: 2;
    }
    @keyframes fireGlow {
      0%, 100% { box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.5), 0 0 15px rgba(249, 115, 22, 0.6); }
      50% { box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.5), 0 0 25px rgba(249, 115, 22, 0.9); }
    }
    
    .monster-king {
      width: 240px; height: 240px;
      position: relative;
      animation: kingPulse 2.5s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes kingPulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(147, 51, 234, 0.5)); }
      50% { transform: scale(1.03); filter: drop-shadow(0 0 30px rgba(147, 51, 234, 0.8)); }
    }
    .monster-king::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #a855f7 0%, #9333ea 30%, #7c3aed 60%, #6d28d9 100%);
      border-radius: 40% 45% 35% 40% / 45% 50% 40% 45%;
      box-shadow: 
        0 30px 60px rgba(147, 51, 234, 0.6),
        inset 0 -50px 80px rgba(109, 40, 217, 0.7),
        inset 0 30px 50px rgba(255, 255, 255, 0.2);
    }
    .king-crown {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      height: 60px;
      background: transparent;
      z-index: 3;
    }
    .king-crown::before {
      content: 'üëë';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      z-index: 1;
    }
    .king-eyes {
      position: absolute;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 48px;
      z-index: 2;
    }
    .king-eye {
      width: 36px;
      height: 44px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 30px rgba(250, 204, 21, 0.95),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
      animation: kingEyeGlow 2s ease-in-out infinite;
    }
    @keyframes kingEyeGlow {
      0%, 100% { box-shadow: 0 0 25px rgba(250, 204, 21, 0.9), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 35px rgba(250, 204, 21, 1), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
    }
    .king-eye::before {
      content: '';
      position: absolute;
      top: 9px;
      left: 9px;
      width: 14px;
      height: 18px;
      background: #1e293b;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .king-eye::after {
      content: '';
      position: absolute;
      top: 11px;
      left: 11px;
      width: 5px;
      height: 7px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
    }
    .king-mouth {
      position: absolute;
      bottom: 58px;
      left: 50%;
      transform: translateX(-50%);
      width: 95px;
      height: 48px;
      background: linear-gradient(to top, #7c3aed, #6d28d9);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        inset 0 10px 20px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(124, 58, 237, 0.6);
      z-index: 1;
    }
    .king-teeth {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
    }
    .king-tooth {
      width: 8px;
      height: 15px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    .king-aura {
      position: absolute;
      inset: -20px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(147, 51, 234, 0.3) 0%, transparent 70%);
      animation: auraPulse 3s ease-in-out infinite;
      z-index: -1;
    }
    @keyframes auraPulse {
      0%, 100% { transform: scale(1); opacity: 0.3; }
      50% { transform: scale(1.1); opacity: 0.5; }
    }
    .monster-lich {
      width: 200px; height: 220px;
      position: relative;
      animation: lichFloat 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes lichFloat {
      0%, 100% { transform: translateY(0) rotate(-1deg); }
      50% { transform: translateY(-5px) rotate(1deg); }
    }
    .monster-lich::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
      border-radius: 45% 50% 35% 40% / 50% 55% 40% 45%;
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.6),
        inset 0 -40px 60px rgba(0, 0, 0, 0.7),
        inset 0 15px 30px rgba(255, 255, 255, 0.1);
    }
    .lich-skull {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 140px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 40% 40%;
      box-shadow: 
        0 10px 20px rgba(0, 0, 0, 0.5),
        inset 0 -20px 30px rgba(0, 0, 0, 0.3);
    }
    .lich-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 2;
    }
    .lich-eye {
      width: 20px;
      height: 25px;
      background: #dc2626;
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.5);
      animation: lichEyeGlow 1.5s ease-in-out infinite;
    }
    @keyframes lichEyeGlow {
      0%, 100% { box-shadow: 0 0 10px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(0, 0, 0, 0.4); }
      50% { box-shadow: 0 0 20px rgba(220, 38, 38, 1), inset 0 0 12px rgba(0, 0, 0, 0.6); }
    }
    .lich-mouth {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 30px;
      border: 3px solid #1e293b;
      border-top: none;
      border-radius: 0 0 50% 50%;
    }
    .lich-robe {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 100px;
      background: linear-gradient(to bottom, #1e293b, #0f172a);
      border-radius: 50% 50% 0 0;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }
    .monster-behemoth {
      width: 260px; height: 280px;
      position: relative;
      animation: behemothRoar 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes behemothRoar {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .monster-behemoth::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #78350f 0%, #92400e 40%, #b45309 100%);
      border-radius: 35% 40% 30% 35% / 50% 55% 35% 40%;
      box-shadow: 
        0 30px 60px rgba(180, 83, 9, 0.5),
        inset 0 -50px 80px rgba(120, 53, 15, 0.6),
        inset 0 20px 40px rgba(255, 255, 255, 0.1);
    }
    .behemoth-head {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 140px;
      background: linear-gradient(135deg, #92400e, #78350f);
      border-radius: 40% 50% 30% 40% / 45% 50% 35% 40%;
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
    }
    .behemoth-eyes {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 60px;
      z-index: 2;
    }
    .behemoth-eye {
      width: 40px;
      height: 35px;
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border-radius: 50%;
      border: 5px solid #78350f;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(220, 38, 38, 0.6);
      position: relative;
    }
    .behemoth-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 10px;
      width: 18px;
      height: 18px;
      background: #b91c1c;
      border-radius: 50%;
    }
    .behemoth-mouth {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 50px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 8px 16px rgba(0, 0, 0, 0.7),
        0 3px 6px rgba(0, 0, 0, 0.4);
    }
    .behemoth-horns {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 80px;
      z-index: 1;
    }
    .behemoth-horn {
      position: absolute;
      width: 25px;
      height: 60px;
      background: linear-gradient(135deg, #525252, #404040);
      border-radius: 50% 0 50% 50%;
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .behemoth-horn-left {
      left: 40px;
      transform: rotate(-20deg);
    }
    .behemoth-horn-right {
      right: 40px;
      transform: rotate(20deg) scaleX(-1);
    }
    .monster-archdemon {
      width: 240px; height: 260px;
      position: relative;
      animation: archdemonHover 2.5s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes archdemonHover {
      0%, 100% { transform: translateY(0) rotate(-2deg); filter: drop-shadow(0 0 25px rgba(239, 68, 68, 0.6)); }
      50% { transform: translateY(-10px) rotate(2deg); filter: drop-shadow(0 0 35px rgba(239, 68, 68, 0.9)); }
    }
    .monster-archdemon::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #991b1b 0%, #dc2626 30%, #ef4444 70%, #f87171 100%);
      border-radius: 40% 45% 35% 40% / 50% 55% 40% 45%;
      box-shadow: 
        0 35px 70px rgba(239, 68, 68, 0.6),
        inset 0 -60px 100px rgba(153, 27, 27, 0.7),
        inset 0 25px 50px rgba(255, 255, 255, 0.15);
    }
    .archdemon-wings {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 180px;
      z-index: 1;
    }
    .archdemon-wing {
      position: absolute;
      width: 90px;
      height: 160px;
      background: linear-gradient(135deg, #7f1d1d, #991b1b);
      border-radius: 0 50% 50% 0;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }
    .archdemon-wing-left {
      left: 10px;
      transform: rotate(-15deg);
      border-radius: 50% 0 0 50%;
    }
    .archdemon-wing-right {
      right: 10px;
      transform: rotate(15deg) scaleX(-1);
    }
    .archdemon-head {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      height: 120px;
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      border-radius: 45% 50% 40% 45% / 50% 55% 35% 40%;
      z-index: 2;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
    }
    .archdemon-eyes {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      z-index: 3;
    }
    .archdemon-eye {
      width: 28px;
      height: 32px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 25px rgba(250, 204, 21, 0.9),
        inset 0 3px 6px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    .archdemon-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      width: 10px;
      height: 12px;
      background: #000;
      border-radius: 50%;
    }
    .archdemon-mouth {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 35px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.7),
        0 0 20px rgba(239, 68, 68, 0.6);
      z-index: 2;
    }
    .monster-chaos {
      width: 280px; height: 280px;
      position: relative;
      animation: chaosPulse 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes chaosPulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 30px rgba(139, 92, 246, 0.6)) drop-shadow(0 0 30px rgba(239, 68, 68, 0.6)); }
      50% { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(139, 92, 246, 0.9)) drop-shadow(0 0 40px rgba(239, 68, 68, 0.9)); }
    }
    .monster-chaos::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%);
      border-radius: 45% 50% 40% 45% / 50% 55% 40% 45%;
      box-shadow: 
        0 40px 80px rgba(124, 58, 237, 0.7),
        inset 0 -60px 100px rgba(109, 40, 217, 0.8),
        inset 0 30px 60px rgba(255, 255, 255, 0.2);
      animation: chaosColorShift 3s ease-in-out infinite;
    }
    @keyframes chaosColorShift {
      0% { background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%); }
      25% { background: linear-gradient(135deg, #ec4899 0%, #ef4444 25%, #7c3aed 50%, #a855f7 75%, #ec4899 100%); }
      50% { background: linear-gradient(135deg, #ef4444 0%, #7c3aed 25%, #a855f7 50%, #ec4899 75%, #ef4444 100%); }
      75% { background: linear-gradient(135deg, #a855f7 0%, #ec4899 25%, #ef4444 50%, #7c3aed 75%, #a855f7 100%); }
      100% { background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%); }
    }
    .chaos-crown {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 160px;
      height: 70px;
      background: transparent;
      z-index: 3;
    }
    .chaos-crown::before {
      content: 'üëë';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 50px;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
      z-index: 1;
      animation: crownRotate 4s linear infinite;
    }
    @keyframes crownRotate {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .chaos-eyes {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 55px;
      z-index: 2;
    }
    .chaos-eye {
      width: 40px;
      height: 48px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 35px rgba(250, 204, 21, 1),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
      animation: chaosEyeGlow 1.5s ease-in-out infinite;
    }
    @keyframes chaosEyeGlow {
      0%, 100% { box-shadow: 0 0 30px rgba(250, 204, 21, 0.9), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 40px rgba(250, 204, 21, 1.2), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
    }
    .chaos-eye::before {
      content: '';
      position: absolute;
      top: 10px;
      left: 12px;
      width: 16px;
      height: 20px;
      background: #1e293b;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .chaos-eye::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 14px;
      width: 6px;
      height: 8px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
    }
    .chaos-mouth {
      position: absolute;
      bottom: 65px;
      left: 50%;
      transform: translateX(-50%);
      width: 110px;
      height: 55px;
      background: linear-gradient(to top, #7c3aed, #6d28d9);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        inset 0 12px 24px rgba(0, 0, 0, 0.6),
        0 0 25px rgba(124, 58, 237, 0.7);
      z-index: 1;
    }
    .chaos-teeth {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .chaos-tooth {
      width: 10px;
      height: 18px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    .chaos-aura {
      position: absolute;
      inset: -30px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(139, 92, 246, 0.4) 0%, rgba(239, 68, 68, 0.4) 50%, transparent 70%);
      animation: chaosAuraPulse 2s ease-in-out infinite;
      z-index: -1;
    }
    @keyframes chaosAuraPulse {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.2); opacity: 0.6; }
    }
    .hp-bar-container {
      width: 100%;
      padding: 0 1rem;
    }
    @media (max-width: 768px) {
      .hp-bar-container {
        padding: 0 0.5rem;
      }
    }
    .hp-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
      font-weight: bold;
      color: #64748b;
    }
    .hp-bar-bg {
      width: 100%;
      height: 1.5rem;
      background: #e2e8f0;
      border-radius: 9999px;
      overflow: hidden;
    }
    .hp-bar-fill {
      height: 100%;
      transition: width 0.5s ease-out;
      border-radius: 9999px;
      background: linear-gradient(to right, #22c55e, #10b981);
      position: relative;
    }
    .hp-bar-fill.low { background: linear-gradient(to right, #ef4444, #dc2626); }
    .hp-bar-fill.medium { background: linear-gradient(to right, #eab308, #f59e0b); }
    .die {
      width: 80px; height: 80px;
      background: white;
      border: 2px solid #f1f5f9;
      border-radius: 1rem;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 4px;
      padding: 8px;
      cursor: pointer;
      position: relative;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transition: all 0.2s;
    }
    @media (max-width: 768px) {
      .die {
        width: 60px;
        height: 60px;
        padding: 6px;
        gap: 3px;
      }
    }
    .die:hover { transform: scale(1.05); }
    .die.selected {
      border: 4px solid #60a5fa;
      box-shadow: 0 0 20px rgba(96, 165, 250, 0.5), 0 8px 0 rgba(0, 0, 0, 0.15);
    }
    .die.stunned {
      opacity: 0.6;
      background: #fef3c7;
    }
    .die.rolling {
      animation: rollDice 0.6s ease-in-out;
      pointer-events: none;
    }
    @keyframes rollDice {
      0% {
        transform: rotate(0deg) scale(1) translateY(0);
      }
      25% {
        transform: rotate(90deg) scale(0.9) translateY(-20px);
      }
      50% {
        transform: rotate(180deg) scale(1.1) translateY(-10px);
      }
      75% {
        transform: rotate(270deg) scale(0.9) translateY(-20px);
      }
      100% {
        transform: rotate(360deg) scale(1) translateY(0);
      }
    }
    .die-pip {
      width: 10px;
      height: 10px;
      background: #1e293b;
      border-radius: 50%;
      transition: opacity 0.1s;
      justify-self: center;
      align-self: center;
    }
    .die.rolling .die-pip {
      animation: valueFlash 0.1s infinite;
    }
    @keyframes valueFlash {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.8;
      }
    }
    /* Ï£ºÏÇ¨ÏúÑ Îàà Ìå®ÌÑ¥ÏùÑ ÏúÑÌïú Í∑∏Î¶¨Îìú ÏúÑÏπò */
    .die-pip.pos-1 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-2-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-2-2 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-3-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-3-2 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-3-3 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-4-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-4-2 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-4-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-4-4 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-5-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-5-2 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-5-3 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-5-4 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-5-5 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-6-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-6-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-6-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-6-4 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-6-5 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-6-6 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-7-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-7-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-7-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-7-4 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-7-5 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-7-6 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-7-7 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-8-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-8-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-8-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-8-4 { grid-column: 2; grid-row: 1; }
    .die-pip.pos-8-5 { grid-column: 2; grid-row: 3; }
    .die-pip.pos-8-6 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-8-7 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-8-8 { grid-column: 3; grid-row: 3; }
    .stun-badge {
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        45deg,
        rgba(239, 68, 68, 0.1),
        rgba(239, 68, 68, 0.1) 10px,
        rgba(220, 38, 38, 0.2) 10px,
        rgba(220, 38, 38, 0.2) 20px
      );
      border-radius: 1rem;
      pointer-events: none;
      z-index: 5;
    }
    .die.stunned {
      opacity: 0.6;
      background: #fef3c7;
      border: 2px solid #ef4444;
    }
    .die.special-dice {
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
      border: 2px solid #f1f5f9;
    }
    .die.special-dice::before {
      content: '‚òÖ';
      position: absolute;
      top: 4px;
      left: 4px;
      font-size: 0.875rem;
      color: #9333ea;
      z-index: 10;
      text-shadow: 0 0 4px rgba(147, 51, 234, 0.5);
    }
    .die.special-dice.selected {
      border: 4px solid #60a5fa;
      box-shadow: 0 0 20px rgba(96, 165, 250, 0.5), 0 8px 0 rgba(0, 0, 0, 0.15);
    }
    .die-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      pointer-events: none;
      z-index: 50;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      margin-bottom: 0.5rem;
      line-height: 1.5;
      min-width: 200px;
      text-align: center;
    }
    .die:hover .die-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-5px);
    }
    .die-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(30, 41, 59, 0.95);
    }
    .score-preview {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(4px);
      border-radius: 1rem;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      margin-bottom: 1rem;
      text-align: center;
    }
    @media (max-width: 768px) {
      .score-preview {
        padding: 0.75rem;
        margin-bottom: 0.75rem;
      }
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-width: 320px;
      margin: 0 auto;
    }
    @media (max-width: 768px) {
      .controls {
        max-width: 100%;
        gap: 0.5rem;
      }
    }
    .btn {
      padding: 1rem 2rem;
      border-radius: 9999px;
      font-size: 1.125rem;
      font-weight: bold;
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }
    @media (max-width: 768px) {
      .btn {
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
      }
    }
    .btn:hover:not(:disabled) { transform: scale(1.05) translateY(-2px); }
    .btn:active:not(:disabled) { transform: scale(0.95); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-roll {
      background: linear-gradient(to right, #6366f1, #8b5cf6);
    }
    .btn-reroll {
      background: linear-gradient(to right, #f59e0b, #f97316);
    }
    .btn-attack {
      background: linear-gradient(to right, #ef4444, #ec4899);
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 1rem;
    }
    .modal {
      background: linear-gradient(to bottom right, #6366f1, #7c3aed);
      border-radius: 1.5rem;
      padding: 2rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 100%;
      text-align: center;
      color: white;
    }
    .reward-option {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }
    .reward-option:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
    }
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .guide-card {
      background: linear-gradient(to bottom right, #6366f1, #7c3aed);
      border-radius: 1.5rem;
      padding: 1.5rem;
      color: white;
      box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.2);
    }
    .guide-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
    }
    .stun-counter {
      text-align: center;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      font-weight: bold;
      color: #f59e0b;
      position: relative;
      display: inline-block;
      cursor: help;
    }
    .stun-counter:hover .stun-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    .stun-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      font-weight: normal;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      pointer-events: none;
      z-index: 50;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      margin-bottom: 0.5rem;
      line-height: 1.5;
      min-width: 280px;
      max-width: 400px;
      text-align: left;
    }
    .stun-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(30, 41, 59, 0.95);
    }
    .rerolls-left {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.125rem;
      font-weight: bold;
      color: #6366f1;
    }
    .owned-rewards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .reward-badge {
      background: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: medium;
    }
    .attack-result {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .attack-result-modal {
      max-width: 400px;
      padding: 1.5rem;
    }
    .attack-result-modal .attack-label {
      font-size: 1.75rem;
      margin-bottom: 0.5rem;
    }
    .counterattack-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      pointer-events: none;
    }
    .counterattack-modal {
      background: linear-gradient(to right, #dc2626, #ea580c);
      border-radius: 1.5rem;
      padding: 2rem;
      color: white;
      text-align: center;
      font-size: 2rem;
      font-weight: black;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback } = React;

    // Game Data
    // Î™¨Ïä§ÌÑ∞ Ïù¥ÎØ∏ÏßÄ ÌååÏùº Í≤ΩÎ°ú (nullÎ°ú ÏÑ§Ï†ïÌïòÎ©¥ ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©)
    const MONSTER_IMAGES = {
      slime: null,   // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      goblin: null,  // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      orc: null,     // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      dragon: null,  // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      demon: null    // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
    };

    const STAGES = [
      { id: 1, name: "Slime", nameKo: "Ïä¨ÎùºÏûÑ", hp: 100, iconName: "Droplet", imageUrl: MONSTER_IMAGES.slime },
      { id: 2, name: "Goblin", nameKo: "Í≥†Î∏îÎ¶∞", hp: 150, iconName: "Skull", imageUrl: MONSTER_IMAGES.goblin },
      { id: 3, name: "Orc", nameKo: "Ïò§ÌÅ¨", hp: 200, iconName: "Axe", imageUrl: MONSTER_IMAGES.orc },
      { id: 4, name: "Dragon", nameKo: "ÎìúÎûòÍ≥§", hp: 300, iconName: "Flame", imageUrl: MONSTER_IMAGES.dragon },
      { id: 5, name: "Demon King", nameKo: "ÎßàÏôï", hp: 400, iconName: "Crown", imageUrl: MONSTER_IMAGES.demon },
      { id: 6, name: "Lich", nameKo: "Î¶¨Ïπò", hp: 500, iconName: "Skull", imageUrl: null },
      { id: 7, name: "Behemoth", nameKo: "Î≤†ÌûàÎ™®Ïä§", hp: 600, iconName: "Axe", imageUrl: null },
      { id: 8, name: "Archdemon", nameKo: "ÏïÑÌÅ¨Îç∞Î™¨", hp: 700, iconName: "Flame", imageUrl: null },
      { id: 9, name: "Chaos Lord", nameKo: "Ïπ¥Ïò§Ïä§ Î°úÎìú", hp: 800, iconName: "Crown", imageUrl: null },
    ];

    const REWARDS = [
      { id: "skilled_hands", name: "Skilled Hands", nameKo: "ÏàôÎ†®Îêú ÏÜêÍ∏∏", descriptionKo: "Î¶¨Î°§ Í∏∞ÌöåÍ∞Ä ÏòÅÍµ¨Ï†ÅÏúºÎ°ú +1Ìöå Ï∂îÍ∞ÄÎê©ÎãàÎã§.", iconName: "Hand", price: 3 },
      { id: "giants_strike", name: "Giant's Strike", nameKo: "Í±∞Ïù∏Ïùò ÏùºÍ≤©", descriptionKo: "Ï£ºÏÇ¨ÏúÑ Ìï©Í≥Ñ 24 Ïù¥ÏÉÅÏãú Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§.", iconName: "Dumbbell", price: 3 },
      { id: "gamblers_chip", name: "Gambler's Chip", nameKo: "Ï∞¨Ïä§ Í∞ïÌôî", descriptionKo: "Ï∞¨Ïä§ Î∞∞ÏàòÍ∞Ä x2Î°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§", iconName: "Coins", price: 3 },
      { id: "cursed_power", name: "Cursed Power", nameKo: "Ï†ÄÏ£ºÎ∞õÏùÄ Ìûò", descriptionKo: "ÏµúÏ¢Ö Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌïòÏßÄÎßå, 1 Ï£ºÏÇ¨ÏúÑ Ìè¨Ìï®Ïãú ÌîºÌï¥Î•º Ï§Ñ Ïàò ÏóÜÏäµÎãàÎã§.", iconName: "Skull", price: 3 },
      { id: "raging_power", name: "Raging Power", nameKo: "Ìè≠Ï£ºÌïòÎäî Ìûò", descriptionKo: "Ï£ºÏÇ¨ÏúÑ +1Í∞ú, Î¶¨Î°§Ïãú Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Ïû¨Íµ¥Î¶ºÎê©ÎãàÎã§", iconName: "Flame", price: 3 },
      { id: "all_two_dice", name: "Triple Dice", nameKo: "Ìä∏Î¶¨Ìîå Îã§Ïù¥Ïä§", descriptionKo: "2Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º 3,3,3,3,3,3 Î©¥ Íµ¨ÏÑ± Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "extreme_dice", name: "Extreme Dice", nameKo: "ÏùµÏä§Ìä∏Î¶º Îã§Ïù¥Ïä§", descriptionKo: "2Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º 0,0,0,6,6,6 Î©¥ Íµ¨ÏÑ± Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "even_dice", name: "Even Dice", nameKo: "ÏßùÏàò Îã§Ïù¥Ïä§", descriptionKo: "2Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º 2,2,4,4,6,6 Î©¥ Íµ¨ÏÑ± Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "odd_dice", name: "Odd Dice", nameKo: "ÌôÄÏàò Îã§Ïù¥Ïä§", descriptionKo: "2Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º 1,3,3,3,5,5 Î©¥ Íµ¨ÏÑ± Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "middle_dice", name: "Middle Dice", nameKo: "Ï§ëÍ∞Ñ Îã§Ïù¥Ïä§", descriptionKo: "2Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º 3,3,3,4,4,4 Î©¥ Íµ¨ÏÑ± Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "triple_boost", name: "Triple Boost", nameKo: "Ìä∏Î¶¨Ìîå Í∞ïÌôî", descriptionKo: "Ìä∏Î¶¨Ìîå Î∞∞ÏàòÍ∞Ä x3Î°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "two_pair_boost", name: "Two Pair Boost", nameKo: "Ìà¨ÌéòÏñ¥ Í∞ïÌôî", descriptionKo: "Ìà¨ÌéòÏñ¥ Î∞∞ÏàòÍ∞Ä x4Î°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "small_straight_boost", name: "Small Straight Boost", nameKo: "Ïä§Î™∞ Ïä§Ìä∏Î†àÏù¥Ìä∏ Í∞ïÌôî", descriptionKo: "Ïä§Î™∞ Ïä§Ìä∏Î†àÏù¥Ìä∏ Î∞∞ÏàòÍ∞Ä x5Î°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "steel_armor", name: "Steel Armor", nameKo: "Í∞ïÏ≤† Ïô∏Ìîº", descriptionKo: "Î™¨Ïä§ÌÑ∞ Ï≤´ Í≥µÍ≤©Ïù¥ Î¨¥Ìö®ÌôîÎê©ÎãàÎã§. Î¶¨Î°§Ïãú Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Íµ¥Î†§ÏßëÎãàÎã§.", iconName: "Target", price: 3 },
      { id: "overload", name: "Overload", nameKo: "Í≥ºÎ∂ÄÌïò", descriptionKo: "Ï£ºÏÇ¨ÏúÑÍ∞Ä 2Í∞úÏî© Í∏∞Ï†àÎê©ÎãàÎã§. Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "final_strike", name: "Final Strike", nameKo: "ÎßàÏßÄÎßâ ÏùºÍ≤©", descriptionKo: "Î™¨Ïä§ÌÑ∞ Ï≤¥Î†•Ïù¥ 50% Ïù¥ÌïòÏùº Í≤ΩÏö∞ Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "blood_contract", name: "Blood Contract", nameKo: "ÌîºÏùò Í≥ÑÏïΩ", descriptionKo: "Ï£ºÏÇ¨ÏúÑ 1Í∞úÎ•º ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ÌååÍ¥¥Ìï©ÎãàÎã§. Îç∞ÎØ∏ÏßÄÍ∞Ä x3Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "odd_power", name: "Odd Power", nameKo: "ÌôÄÏàòÏùò Ìûò", descriptionKo: "Î™®Îì† Ï£ºÏÇ¨ÏúÑ ÎààÏù¥ ÌôÄÏàòÏù¥Î©¥ Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "even_power", name: "Even Power", nameKo: "ÏßùÏàòÏùò Ìûò", descriptionKo: "Î™®Îì† Ï£ºÏÇ¨ÏúÑ ÎààÏù¥ ÏßùÏàòÏù¥Î©¥ Îç∞ÎØ∏ÏßÄÍ∞Ä x2Î∞∞ Ï¶ùÍ∞ÄÌï©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "full_house_boost", name: "Full House Boost", nameKo: "ÌíÄ ÌïòÏö∞Ïä§ Í∞ïÌôî", descriptionKo: "ÌíÄ ÌïòÏö∞Ïä§ Î∞∞ÏàòÍ∞Ä x8Î°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§", iconName: "Target", price: 3 },
      { id: "dice_plus_one_stack", name: "Dice Plus One Stack", nameKo: "Ï£ºÏÇ¨ÏúÑ ÎààÍ∏à +1 Ïä§ÌÉù", descriptionKo: "Ï£ºÏÇ¨ÏúÑ ÎààÍ∏à +1 ÏÇ¨Ïö© ÌöüÏàòÎ•º 1Ìöå Ï∂îÍ∞ÄÌï©ÎãàÎã§ (ÏµúÎåÄ 3Ïä§ÌÉù)", iconName: "Plus", price: 1 },
      { id: "dice_flip_stack", name: "Dice Flip Stack", nameKo: "Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ Ïä§ÌÉù", descriptionKo: "Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ ÏÇ¨Ïö© ÌöüÏàòÎ•º 1Ìöå Ï∂îÍ∞ÄÌï©ÎãàÎã§ (ÏµúÎåÄ 3Ïä§ÌÉù)", iconName: "Rotate", price: 2 },
    ];

    const COMBINATIONS = {
      yahtzee: { multiplier: 20, label: "Yahtzee", labelKo: "ÏïºÏ∞å (5Í∞ú ÎèôÏùº)" },
      largeStraight: { multiplier: 10, label: "Large Straight", labelKo: "ÎùºÏßÄ Ïä§Ìä∏Î†àÏù¥Ìä∏ (5Í∞ú Ïó∞ÏÜç)" },
      fourOfAKind: { multiplier: 8, label: "4 of a Kind", labelKo: "Ìè¨Ïπ¥Îìú (4Í∞ú ÎèôÏùº)" },
      fullHouse: { multiplier: 6, label: "Full House", labelKo: "ÌíÄ ÌïòÏö∞Ïä§ (3+2)" },
      smallStraight: { multiplier: 4, label: "Small Straight", labelKo: "Ïä§Î™∞ Ïä§Ìä∏Î†àÏù¥Ìä∏ (4Í∞ú Ïó∞ÏÜç)" },
      twoPair: { multiplier: 3, label: "Two Pair", labelKo: "Ìà¨ÌéòÏñ¥ (2Ïåç)" },
      threeOfAKind: { multiplier: 2, label: "3 of a Kind", labelKo: "Ìä∏Î¶¨Ìîå (3Í∞ú ÎèôÏùº)" },
      chance: { multiplier: 1, label: "Chance", labelKo: "Ï∞¨Ïä§" },
    };

    // Scoring Logic
    function getCounts(dice) {
      const counts = new Map();
      for (const die of dice) {
        counts.set(die, (counts.get(die) || 0) + 1);
      }
      return counts;
    }

    function isYahtzee(counts, diceCount) {
      return diceCount >= 5 && Array.from(counts.values()).some(count => count >= 5);
    }

    function isLargeStraight(dice) {
      if (dice.length < 5) return false;
      const sorted = [...dice].sort((a, b) => a - b);
      const unique = Array.from(new Set(sorted));
      if (unique.length < 5) return false;
      for (let i = 0; i <= unique.length - 5; i++) {
        let consecutive = true;
        for (let j = 0; j < 4; j++) {
          if (unique[i + j + 1] - unique[i + j] !== 1) {
            consecutive = false;
            break;
          }
        }
        if (consecutive) return true;
      }
      return false;
    }

    function isSmallStraight(dice) {
      const unique = Array.from(new Set(dice)).sort((a, b) => a - b);
      const sequences = [[0,1,2,3], [1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7], [5,6,7,8]];
      return sequences.some(seq => seq.every(num => unique.includes(num)));
    }

    function hasThreeConsecutive(dice) {
      const unique = Array.from(new Set(dice)).sort((a, b) => a - b);
      if (unique.length < 3) return false;
      for (let i = 0; i <= unique.length - 3; i++) {
        if (unique[i + 1] - unique[i] === 1 && unique[i + 2] - unique[i + 1] === 1) {
          return true;
        }
      }
      return false;
    }

    function detectCombination(dice) {
      const counts = getCounts(dice);
      const diceCount = dice.length;
      if (isYahtzee(counts, diceCount)) return "yahtzee";
      if (isLargeStraight(dice)) return "largeStraight";
      if (Array.from(counts.values()).some(c => c >= 4)) return "fourOfAKind";
      const sorted = Array.from(counts.values()).sort((a, b) => b - a);
      if (diceCount >= 5 && sorted.length === 2 && sorted[0] === 3 && sorted[1] === 2) return "fullHouse";
      if (isSmallStraight(dice)) return "smallStraight";
      const pairs = Array.from(counts.values()).filter(c => c >= 2);
      if (pairs.length >= 2) return "twoPair";
      if (Array.from(counts.values()).some(c => c >= 3)) return "threeOfAKind";
      return "chance";
    }

    function calculateScore(dice, options = {}) {
      const { ownedRewards = [], monsterHp = 0, maxMonsterHp = 0, diceEnhancements = [] } = options;
      let sum = dice.reduce((a, b) => a + b, 0);
      
      // Í∞ïÌôîÎêú Ï£ºÏÇ¨ÏúÑÍ∞Ä Ï°∞Ìï©Ïóê ÏÇ¨Ïö©ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† Ìï©Í≥ÑÏóê Ï∂îÍ∞Ä
      // Ï°∞Ìï©ÏùÑ ÎßåÎì§ Îïå ÏÇ¨Ïö©Îêú Ï£ºÏÇ¨ÏúÑÎì§ÏùÑ Ï∂îÏ†ÅÌïòÍ∏∞ ÏúÑÌï¥, Í∞Å Ï£ºÏÇ¨ÏúÑ Í∞íÏù¥ Ï°∞Ìï©Ïóê Ìè¨Ìï®ÎêòÎäîÏßÄ ÌôïÏù∏
      const diceCounts = getCounts(dice);
      const combination = detectCombination(dice);
      
      // Ï°∞Ìï©Ïóê ÏÇ¨Ïö©Îêú Ï£ºÏÇ¨ÏúÑÎì§Ïùò Í∞ïÌôî Î†àÎ≤® Ìï©Í≥Ñ Í≥ÑÏÇ∞
      let enhancementBonus = 0;
      if (diceEnhancements.length > 0) {
        // Ï°∞Ìï©Ïóê ÏÇ¨Ïö©Îêú Ï£ºÏÇ¨ÏúÑÎì§ÏùÑ ÌôïÏù∏
        const usedDice = new Set();
        const sortedDice = [...dice].map((value, idx) => ({ value, idx })).sort((a, b) => a.value - b.value);
        
        // Ï°∞Ìï© ÌÉÄÏûÖÏóê Îî∞Îùº ÏÇ¨Ïö©Îêú Ï£ºÏÇ¨ÏúÑ ÌôïÏù∏
        if (combination === "yahtzee") {
          // Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∞ôÏùÄ Í∞í
          sortedDice.forEach(({ idx }) => {
            if (diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
            }
          });
        } else if (combination === "fourOfAKind") {
          // 4Í∞úÍ∞Ä Í∞ôÏùÄ Í∞í - 4Í∞úÎßå ÏÇ¨Ïö©
          const counts = getCounts(dice);
          const fourValue = Array.from(counts.entries()).find(([_, count]) => count >= 4)?.[0];
          let usedCount = 0;
          sortedDice.forEach(({ value, idx }) => {
            if (value === fourValue && usedCount < 4 && diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
              usedCount++;
            }
          });
        } else if (combination === "fullHouse") {
          // 3Í∞ú + 2Í∞ú - 5Í∞ú Î™®Îëê ÏÇ¨Ïö©
          const counts = getCounts(dice);
          const threeValue = Array.from(counts.entries()).find(([_, count]) => count >= 3)?.[0];
          const twoValue = Array.from(counts.entries()).find(([_, count]) => count >= 2 && count < 3)?.[0];
          sortedDice.forEach(({ value, idx }) => {
            if ((value === threeValue || value === twoValue) && diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
            }
          });
        } else if (combination === "threeOfAKind") {
          // 3Í∞úÍ∞Ä Í∞ôÏùÄ Í∞í - 3Í∞úÎßå ÏÇ¨Ïö©
          const counts = getCounts(dice);
          const threeValue = Array.from(counts.entries()).find(([_, count]) => count >= 3)?.[0];
          let usedCount = 0;
          sortedDice.forEach(({ value, idx }) => {
            if (value === threeValue && usedCount < 3 && diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
              usedCount++;
            }
          });
        } else if (combination === "twoPair") {
          // 2Ïåç - 4Í∞ú ÏÇ¨Ïö© (2Í∞úÏî© 2Ïåç)
          const counts = getCounts(dice);
          const pairValues = Array.from(counts.entries()).filter(([_, count]) => count >= 2).map(([value]) => value);
          const usedCounts = new Map();
          pairValues.forEach(val => usedCounts.set(val, 0));
          sortedDice.forEach(({ value, idx }) => {
            if (pairValues.includes(value) && usedCounts.get(value) < 2 && diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
              usedCounts.set(value, usedCounts.get(value) + 1);
            }
          });
        } else {
          // largeStraight, smallStraight, chance: Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Ï°∞Ìï©Ïóê ÏÇ¨Ïö©Îê®
          sortedDice.forEach(({ idx }) => {
            if (diceEnhancements[idx] > 0) {
              enhancementBonus += diceEnhancements[idx];
            }
          });
        }
      }
      
      sum += enhancementBonus;
      let { multiplier, label, labelKo } = COMBINATIONS[combination];
      
      // Ï°±Î≥¥ Í∞ïÌôî Î≥¥ÏÉÅ Ï†ÅÏö©
      if (combination === "threeOfAKind" && ownedRewards.includes("triple_boost")) {
        multiplier = 3;
      }
      if (combination === "twoPair" && ownedRewards.includes("two_pair_boost")) {
        multiplier = 4;
      }
      if (combination === "smallStraight" && ownedRewards.includes("small_straight_boost")) {
        multiplier = 5;
      }
      if (combination === "fullHouse" && ownedRewards.includes("full_house_boost")) {
        multiplier = 8;
      }
      
      if (combination === "chance" && ownedRewards.includes("gamblers_chip")) {
        multiplier *= 2;
      }
      
      const rewardMultipliers = [];
      let isCursed = false;
      
      if (ownedRewards.includes("cursed_power")) {
        if (dice.some(d => d === 1)) {
          isCursed = true;
        } else {
          rewardMultipliers.push({ rewardId: "cursed_power", multiplier: 2 });
        }
      }
      
      if (!isCursed) {
        if (ownedRewards.includes("giants_strike") && sum >= 24) {
          rewardMultipliers.push({ rewardId: "giants_strike", multiplier: 2 });
        }
        if (ownedRewards.includes("overload")) {
          rewardMultipliers.push({ rewardId: "overload", multiplier: 2 });
        }
        if (ownedRewards.includes("final_strike") && maxMonsterHp > 0 && monsterHp <= maxMonsterHp * 0.5) {
          rewardMultipliers.push({ rewardId: "final_strike", multiplier: 2 });
        }
        if (ownedRewards.includes("blood_contract")) {
          rewardMultipliers.push({ rewardId: "blood_contract", multiplier: 3 });
        }
        // ÌôÄÏàòÏùò Ìûò: Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä ÌôÄÏàòÏù∏ÏßÄ Ï≤¥ÌÅ¨
        if (ownedRewards.includes("odd_power") && dice.every(d => d % 2 === 1 && d > 0)) {
          rewardMultipliers.push({ rewardId: "odd_power", multiplier: 2 });
        }
        // ÏßùÏàòÏùò Ìûò: Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä ÏßùÏàòÏù∏ÏßÄ Ï≤¥ÌÅ¨ (0ÏùÄ Ï†úÏô∏)
        if (ownedRewards.includes("even_power") && dice.every(d => d % 2 === 0 && d > 0)) {
          rewardMultipliers.push({ rewardId: "even_power", multiplier: 2 });
        }
      }
      
      const finalMultiplier = rewardMultipliers.reduce((acc, r) => acc * r.multiplier, 1);
      const baseTotal = sum * multiplier;
      const total = isCursed ? 0 : baseTotal * finalMultiplier;
      
      return { combination, multiplier, sum, total, label, labelKo, rewardMultipliers, finalMultiplier, isCursed };
    }

    // Game Logic
    function getInitialPlayerState() {
      return {
        ownedRewards: [],
        encounteredRewards: [],
        baseRerolls: 2,
        diceTypes: ["normal", "normal", "normal", "normal", "normal"],
        holdDisabled: false,
        currentStage: 1,
        firstAttackBlocked: false,
        gold: 0,
        dicePlusOneStacks: 1,
        diceFlipStacks: 1,
        diceEnhancements: [0, 0, 0, 0, 0], // Í∞Å Ï£ºÏÇ¨ÏúÑÏùò Í∞ïÌôî Î†àÎ≤®
        diceEnhanceCharges: 0, // Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî ÏÇ¨Ïö© Í∞ÄÎä• ÌöüÏàò
      };
    }

    function rollDieByType(type, isStunned = false) {
      if (isStunned) {
        const stunnedValues = [0, 0, 0, 1, 1, 1];
        return stunnedValues[Math.floor(Math.random() * 6)];
      }
      switch (type) {
        case "d8": return Math.floor(Math.random() * 8) + 1;
        case "d6_2_7": return Math.floor(Math.random() * 6) + 2;
        case "all_two": return 3; // Ìï≠ÏÉÅ 3
        case "extreme": {
          const extremeValues = [0, 0, 0, 6, 6, 6];
          return extremeValues[Math.floor(Math.random() * 6)];
        }
        case "even": {
          const evenValues = [2, 2, 4, 4, 6, 6];
          return evenValues[Math.floor(Math.random() * 6)];
        }
        case "odd": {
          const oddValues = [1, 3, 3, 3, 5, 5];
          return oddValues[Math.floor(Math.random() * 6)];
        }
        case "middle": {
          const middleValues = [3, 3, 3, 4, 4, 4];
          return middleValues[Math.floor(Math.random() * 6)];
        }
        default: return Math.floor(Math.random() * 6) + 1;
      }
    }

    function getRandomRewards(count, excludeIds = []) {
      const available = REWARDS.filter(r => !excludeIds.includes(r.id));
      const shuffled = [...available].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    }

    function applyReward(state, rewardId) {
      const newState = { ...state, ownedRewards: [...state.ownedRewards, rewardId] };
      switch (rewardId) {
        case "skilled_hands":
          newState.baseRerolls += 1;
          break;
        case "raging_power":
          newState.diceTypes = [...newState.diceTypes, "normal"];
          newState.holdDisabled = true;
          break;
        case "all_two_dice": {
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 2; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = "all_two";
              changed++;
            }
          }
          break;
        }
        case "extreme_dice": {
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 2; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = "extreme";
              changed++;
            }
          }
          break;
        }
        case "even_dice": {
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 2; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = "even";
              changed++;
            }
          }
          break;
        }
        case "odd_dice": {
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 2; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = "odd";
              changed++;
            }
          }
          break;
        }
        case "middle_dice": {
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 2; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = "middle";
              changed++;
            }
          }
          break;
        }
        case "steel_armor":
          newState.holdDisabled = true;
          newState.firstAttackBlocked = true;
          break;
        case "blood_contract":
          if (newState.diceTypes.length > 1) {
            newState.diceTypes = newState.diceTypes.slice(0, -1);
          }
          break;
      }
      return newState;
    }

    function triggerConfetti(scoreResult) {
      if (scoreResult.multiplier >= 20) {
        confetti({ particleCount: 200, spread: 100, origin: { y: 0.5 }, colors: ["#FFD700", "#FFA500", "#FF6347"] });
      } else if (scoreResult.multiplier >= 10) {
        confetti({ particleCount: 150, spread: 80, origin: { y: 0.6 }, colors: ["#9333ea", "#6366f1", "#ec4899"] });
      } else if (scoreResult.multiplier >= 6) {
        confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ["#3b82f6", "#06b6d4"] });
      } else if (scoreResult.multiplier >= 4) {
        confetti({ particleCount: 50, spread: 50, origin: { y: 0.6 }, colors: ["#22c55e", "#10b981"] });
      }
    }

    function triggerVictoryConfetti() {
      const duration = 3000;
      const end = Date.now() + duration;
      const frame = () => {
        confetti({ particleCount: 7, angle: 60, spread: 55, origin: { x: 0 }, colors: ["#FFD700", "#FFA500", "#FF6347", "#9333ea", "#3b82f6"] });
        confetti({ particleCount: 7, angle: 120, spread: 55, origin: { x: 1 }, colors: ["#FFD700", "#FFA500", "#FF6347", "#9333ea", "#3b82f6"] });
        if (Date.now() < end) requestAnimationFrame(frame);
      };
      frame();
    }

    // Ï£ºÏÇ¨ÏúÑ Îàà Ìå®ÌÑ¥ ÏÉùÏÑ± Ìï®Ïàò
    function renderDicePips(value) {
      if (value === 0) {
        return <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontWeight: 'bold' }}>0</div>; // 0 Í∞í ÌëúÏãú
      }
      
      const pips = [];
      
      if (value === 1) {
        pips.push(<div key="1" className="die-pip pos-1" />);
      } else if (value === 2) {
        pips.push(<div key="1" className="die-pip pos-2-1" />);
        pips.push(<div key="2" className="die-pip pos-2-2" />);
      } else if (value === 3) {
        pips.push(<div key="1" className="die-pip pos-3-1" />);
        pips.push(<div key="2" className="die-pip pos-3-2" />);
        pips.push(<div key="3" className="die-pip pos-3-3" />);
      } else if (value === 4) {
        pips.push(<div key="1" className="die-pip pos-4-1" />);
        pips.push(<div key="2" className="die-pip pos-4-2" />);
        pips.push(<div key="3" className="die-pip pos-4-3" />);
        pips.push(<div key="4" className="die-pip pos-4-4" />);
      } else if (value === 5) {
        pips.push(<div key="1" className="die-pip pos-5-1" />);
        pips.push(<div key="2" className="die-pip pos-5-2" />);
        pips.push(<div key="3" className="die-pip pos-5-3" />);
        pips.push(<div key="4" className="die-pip pos-5-4" />);
        pips.push(<div key="5" className="die-pip pos-5-5" />);
      } else if (value === 6) {
        pips.push(<div key="1" className="die-pip pos-6-1" />);
        pips.push(<div key="2" className="die-pip pos-6-2" />);
        pips.push(<div key="3" className="die-pip pos-6-3" />);
        pips.push(<div key="4" className="die-pip pos-6-4" />);
        pips.push(<div key="5" className="die-pip pos-6-5" />);
        pips.push(<div key="6" className="die-pip pos-6-6" />);
      } else if (value === 7) {
        pips.push(<div key="1" className="die-pip pos-7-1" />);
        pips.push(<div key="2" className="die-pip pos-7-2" />);
        pips.push(<div key="3" className="die-pip pos-7-3" />);
        pips.push(<div key="4" className="die-pip pos-7-4" />);
        pips.push(<div key="5" className="die-pip pos-7-5" />);
        pips.push(<div key="6" className="die-pip pos-7-6" />);
        pips.push(<div key="7" className="die-pip pos-7-7" />);
      } else if (value === 8) {
        pips.push(<div key="1" className="die-pip pos-8-1" />);
        pips.push(<div key="2" className="die-pip pos-8-2" />);
        pips.push(<div key="3" className="die-pip pos-8-3" />);
        pips.push(<div key="4" className="die-pip pos-8-4" />);
        pips.push(<div key="5" className="die-pip pos-8-5" />);
        pips.push(<div key="6" className="die-pip pos-8-6" />);
        pips.push(<div key="7" className="die-pip pos-8-7" />);
        pips.push(<div key="8" className="die-pip pos-8-8" />);
      }
      
      return pips;
    }

    // Components
    function getDiceTypeInfo(diceType) {
      const typeInfo = {
        "all_two": { name: "Ìä∏Î¶¨Ìîå Îã§Ïù¥Ïä§", faces: [3,3,3,3,3,3] },
        "extreme": { name: "ÏùµÏä§Ìä∏Î¶º Îã§Ïù¥Ïä§", faces: [0,0,0,6,6,6] },
        "even": { name: "ÏßùÏàò Îã§Ïù¥Ïä§", faces: [2,2,4,4,6,6] },
        "odd": { name: "ÌôÄÏàò Îã§Ïù¥Ïä§", faces: [1,3,3,3,5,5] },
        "middle": { name: "Ï§ëÍ∞Ñ Îã§Ïù¥Ïä§", faces: [3,3,3,4,4,4] },
        "d8": { name: "Ï∞®Ïõê ÏôúÍ≥°", faces: [1,2,3,4,5,6,7,8] },
        "d6_2_7": { name: "ÏïàÏ†ïÏ†ÅÏù∏ ÏóîÏßÑ", faces: [2,3,4,5,6,7] },
      };
      return typeInfo[diceType] || null;
    }

    function Die({ value, isSelected, isStunned, isRolling, diceType, onToggle, selectionDisabled, index, enhancementLevel = 0 }) {
      const [displayValue, setDisplayValue] = useState(value);
      const diceTypeInfo = getDiceTypeInfo(diceType);
      const isSpecialDice = diceTypeInfo !== null;
      
      useEffect(() => {
        if (isRolling) {
          // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ë Í∞íÏù¥ ÎûúÎç§ÌïòÍ≤å Î∞îÎÄåÎäî Ìö®Í≥º
          const interval = setInterval(() => {
            const randomValue = Math.floor(Math.random() * 6) + 1;
            setDisplayValue(randomValue);
          }, 100);
          return () => clearInterval(interval);
        } else {
          setDisplayValue(value);
        }
      }, [isRolling, value]);
      
      const dieClass = `die ${isSelected ? 'selected' : ''} ${isStunned ? 'stunned' : ''} ${isRolling ? 'rolling' : ''} ${isSpecialDice ? 'special-dice' : ''} ${enhancementLevel > 0 ? 'enhanced' : ''}`;
      const animationDelay = isRolling ? `${index * 0.05}s` : '0s';
      
      return (
        <div 
          className={dieClass} 
          onClick={!selectionDisabled && !isRolling && onToggle}
          style={{ animationDelay }}
        >
          {renderDicePips(displayValue)}
          {isStunned && <div className="stun-badge" />}
          {enhancementLevel > 0 && (
            <div style={{
              position: 'absolute',
              top: '2px',
              right: '2px',
              background: 'linear-gradient(135deg, #fbbf24, #f59e0b)',
              color: 'white',
              borderRadius: '50%',
              width: '20px',
              height: '20px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '0.75rem',
              fontWeight: 'bold',
              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)',
              zIndex: 10
            }}>
              +{enhancementLevel}
            </div>
          )}
          {isSpecialDice && (
            <div className="die-tooltip">
              <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{diceTypeInfo.name}</div>
              <div>ÎààÍ∏à: {diceTypeInfo.faces.join(', ')}</div>
            </div>
          )}
        </div>
      );
    }

    function Monster({ name, nameKo, maxHp, currentHp, showDamage, damage, isMonsterAttacking, imageUrl }) {
      const hpPercentage = Math.max(0, (currentHp / maxHp) * 100);
      const hpBarClass = `hp-bar-fill ${hpPercentage > 50 ? '' : hpPercentage > 25 ? 'medium' : 'low'}`;
      const [imageError, setImageError] = useState(false);
      
      let monsterBody;
      
      if (imageUrl && !imageError) {
        // Í∞Å Î™¨Ïä§ÌÑ∞ÎßàÎã§ Î≥ÑÎèÑ Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ¨Ïö©
        monsterBody = (
          <img 
            src={imageUrl} 
            alt={nameKo || name}
            className="monster-image"
            onError={() => setImageError(true)}
          />
        );
      } else {
        // Í∏∞Ï°¥ CSS Î∞©Ïãù (imageUrlÏù¥ ÏóÜÍ±∞ÎÇò Î°úÎìú Ïã§Ìå® Ïãú)
        if (name === "Slime" || nameKo === "Ïä¨ÎùºÏûÑ") {
          monsterBody = (
            <div className="monster-slime">
              <div className="slime-eyes">
                <div className="slime-eye" />
                <div className="slime-eye" />
              </div>
              <div className="slime-mouth" />
              <div className="slime-bubbles" />
            </div>
          );
        } else if (name === "Goblin" || nameKo === "Í≥†Î∏îÎ¶∞") {
          monsterBody = (
            <div className="monster-goblin">
              <div className="goblin-ears">
                <div className="goblin-ear-left" />
                <div className="goblin-ear-right" />
              </div>
              <div className="goblin-eyes">
                <div className="goblin-eye" />
                <div className="goblin-eye" />
              </div>
              <div className="goblin-nose" />
              <div className="goblin-mouth">
                <div className="goblin-tooth" />
                <div className="goblin-tooth" />
                <div className="goblin-tooth" />
              </div>
            </div>
          );
        } else if (name === "Orc" || nameKo === "Ïò§ÌÅ¨") {
          monsterBody = (
            <div className="monster-orc">
              <div className="orc-ears">
                <div className="orc-ear-left" />
                <div className="orc-ear-right" />
              </div>
              <div className="orc-eyes">
                <div className="orc-eye" />
                <div className="orc-eye" />
              </div>
              <div className="orc-nose" />
              <div className="orc-tusks">
                <div className="orc-tusk orc-tusk-left" />
                <div className="orc-tusk orc-tusk-right" />
              </div>
              <div className="orc-mouth" />
            </div>
          );
        } else if (name === "Dragon" || nameKo === "ÎìúÎûòÍ≥§") {
          monsterBody = (
            <div className="monster-dragon">
              <div className="dragon-horns">
                <div className="dragon-horn-left" />
                <div className="dragon-horn-right" />
              </div>
              <div className="dragon-eyes">
                <div className="dragon-eye" />
                <div className="dragon-eye" />
              </div>
              <div className="dragon-snout">
                <div className="dragon-nostrils">
                  <div className="dragon-nostril" />
                  <div className="dragon-nostril" />
                </div>
              </div>
              <div className="dragon-mouth" />
            </div>
          );
        } else if (name === "Lich" || nameKo === "Î¶¨Ïπò") {
          monsterBody = (
            <div className="monster-lich">
              <div className="lich-skull">
                <div className="lich-eyes">
                  <div className="lich-eye" />
                  <div className="lich-eye" />
                </div>
                <div className="lich-mouth" />
              </div>
              <div className="lich-robe" />
            </div>
          );
        } else if (name === "Behemoth" || nameKo === "Î≤†ÌûàÎ™®Ïä§") {
          monsterBody = (
            <div className="monster-behemoth">
              <div className="behemoth-horns">
                <div className="behemoth-horn behemoth-horn-left" />
                <div className="behemoth-horn behemoth-horn-right" />
              </div>
              <div className="behemoth-head">
                <div className="behemoth-eyes">
                  <div className="behemoth-eye" />
                  <div className="behemoth-eye" />
                </div>
                <div className="behemoth-mouth" />
              </div>
            </div>
          );
        } else if (name === "Archdemon" || nameKo === "ÏïÑÌÅ¨Îç∞Î™¨") {
          monsterBody = (
            <div className="monster-archdemon">
              <div className="archdemon-wings">
                <div className="archdemon-wing archdemon-wing-left" />
                <div className="archdemon-wing archdemon-wing-right" />
              </div>
              <div className="archdemon-head">
                <div className="archdemon-eyes">
                  <div className="archdemon-eye" />
                  <div className="archdemon-eye" />
                </div>
                <div className="archdemon-mouth" />
              </div>
            </div>
          );
        } else if (name === "Chaos Lord" || nameKo === "Ïπ¥Ïò§Ïä§ Î°úÎìú") {
          monsterBody = (
            <div className="monster-chaos">
              <div className="chaos-aura" />
              <div className="chaos-crown" />
              <div className="chaos-eyes">
                <div className="chaos-eye" />
                <div className="chaos-eye" />
              </div>
              <div className="chaos-mouth">
                <div className="chaos-teeth">
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                </div>
              </div>
            </div>
          );
        } else {
          monsterBody = (
            <div className="monster-king">
              <div className="king-aura" />
              <div className="king-crown" />
              <div className="king-eyes">
                <div className="king-eye" />
                <div className="king-eye" />
              </div>
              <div className="king-mouth">
                <div className="king-teeth">
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                </div>
              </div>
            </div>
          );
        }
      }
      
      return (
        <div className="monster-container">
          <div className={`monster-body ${isMonsterAttacking ? 'attacking' : ''}`}>
            {monsterBody}
            <div style={{ marginTop: '0.75rem', fontSize: '1.125rem', fontWeight: 'bold', color: '#1e293b' }}>{nameKo || name}</div>
            {isMonsterAttacking && (
              <div className="monster-attack-effect">
                <div className="monster-attack-flash" />
              </div>
            )}
          </div>
          <div className="hp-bar-container">
            <div className="hp-label">
              <span>HP</span>
              <span>{Math.max(0, currentHp)} / {maxHp}</span>
            </div>
            <div className="hp-bar-bg">
              <div className={hpBarClass} style={{ width: `${hpPercentage}%` }} />
            </div>
            {showDamage && damage > 0 && (
              <div style={{ textAlign: 'center', marginTop: '0.5rem', fontSize: '2rem', fontWeight: 'bold', color: '#ef4444' }}>
                -{damage}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Main Game Component
    function Game() {
      const [playerState, setPlayerState] = useState(getInitialPlayerState);
      const [currentDice, setCurrentDice] = useState(() => {
        const initialDiceCount = getInitialPlayerState().diceTypes.length;
        return Array.from({ length: initialDiceCount }, (_, i) => i + 1);
      });
      const [selectedIndices, setSelectedIndices] = useState(new Set());
      const [rerollsLeft, setRerollsLeft] = useState(2);
      const [roundStarted, setRoundStarted] = useState(false);
      
      const currentStage = STAGES[playerState.currentStage - 1];
      const [monsterHp, setMonsterHp] = useState(currentStage.hp);
      const [lastDamage, setLastDamage] = useState(0);
      const [showDamage, setShowDamage] = useState(false);
      const [attackResult, setAttackResult] = useState(null);
      const [showAttackResult, setShowAttackResult] = useState(false);
      
      const [stunnedIndices, setStunnedIndices] = useState(new Set());
      const [beingStunnedIndex, setBeingStunnedIndex] = useState(null);
      const [showCounterattack, setShowCounterattack] = useState(false);
      const [isMonsterAttacking, setIsMonsterAttacking] = useState(false);
      const [isPlayerAttacking, setIsPlayerAttacking] = useState(false);
      const [showRerollWarning, setShowRerollWarning] = useState(false);
      const [showDiceModifyWarning, setShowDiceModifyWarning] = useState(false);
      const [isRolling, setIsRolling] = useState(false);
      const [rollingDice, setRollingDice] = useState(new Set());
      
      const [showRewardSelection, setShowRewardSelection] = useState(false);
      const [rewardOptions, setRewardOptions] = useState([]);
      const [showVictory, setShowVictory] = useState(false);
      const [showMonsterPreview, setShowMonsterPreview] = useState(false);

      const totalDiceCount = playerState.diceTypes.length;
      const stunnedDiceCount = stunnedIndices.size;
      const normalDiceCount = totalDiceCount - stunnedDiceCount;
      const effectiveMaxRerolls = playerState.baseRerolls;

      // ÎùºÏö¥ÎìúÍ∞Ä ÏãúÏûëÎêòÏßÄ ÏïäÏïòÏùÑ Îïå Ï£ºÏÇ¨ÏúÑÎ•º ÏàúÏÑúÎåÄÎ°ú ÌëúÏãú
      useEffect(() => {
        if (!roundStarted) {
          setCurrentDice(Array.from({ length: totalDiceCount }, (_, i) => i + 1));
        }
      }, [roundStarted, totalDiceCount]);

      useEffect(() => {
        const stage = STAGES[playerState.currentStage - 1];
        if (stage) setMonsterHp(stage.hp);
      }, [playerState.currentStage]);


      const currentScore = useMemo(() => {
        return calculateScore(currentDice, { 
          ownedRewards: playerState.ownedRewards,
          monsterHp: monsterHp,
          maxMonsterHp: currentStage.hp,
          diceEnhancements: playerState.diceEnhancements || []
        });
      }, [currentDice, playerState.ownedRewards, monsterHp, currentStage]);

      const toggleSelect = (index) => {
        if (!roundStarted) return;
        // Î¶¨Î°§Í∂åÏù¥ ÏóÜÏñ¥ÎèÑ Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ÎÇò +1 Ïä§ÌÉùÏù¥ ÏûàÏúºÎ©¥ ÏÑ†ÌÉù Í∞ÄÎä•
        const hasDiceModifyStacks = (playerState.dicePlusOneStacks > 0 || playerState.diceFlipStacks > 0);
        if (rerollsLeft === 0 && !hasDiceModifyStacks) return;
        setSelectedIndices(prev => {
          const newSet = new Set(prev);
          if (newSet.has(index)) newSet.delete(index);
          else newSet.add(index);
          return newSet;
        });
      };

      const executeCounterattack = useCallback(() => {
        // Í∞ïÏ≤† Ïô∏Ìîº: Ï≤´ Í≥µÍ≤© Î¨¥Ìö®Ìôî
        if (playerState.firstAttackBlocked && playerState.ownedRewards.includes("steel_armor")) {
          const newState = { ...playerState, firstAttackBlocked: false };
          setPlayerState(newState);
          setRoundStarted(false);
          setSelectedIndices(new Set());
          setRerollsLeft(playerState.baseRerolls);
          return;
        }
        
        const activeIndices = Array.from({ length: totalDiceCount }, (_, i) => i).filter(i => !stunnedIndices.has(i));
        if (activeIndices.length === 0) {
          setRoundStarted(false);
          setSelectedIndices(new Set());
          setRerollsLeft(effectiveMaxRerolls);
          return;
        }
        setShowCounterattack(true);
        setIsMonsterAttacking(true);
        setTimeout(() => {
          // Í≥ºÎ∂ÄÌïò: 2Í∞úÏî© Í∏∞Ï†à
          const stunnedCount = playerState.ownedRewards.includes("overload") ? 2 : 1;
          const indicesToStun = [];
          for (let i = 0; i < stunnedCount && activeIndices.length > indicesToStun.length; i++) {
            const available = activeIndices.filter(idx => !indicesToStun.includes(idx));
            if (available.length > 0) {
              indicesToStun.push(available[Math.floor(Math.random() * available.length)]);
            }
          }
          
          if (indicesToStun.length > 0) {
            setBeingStunnedIndex(indicesToStun[0]);
            setTimeout(() => {
              setStunnedIndices(prev => new Set([...Array.from(prev), ...indicesToStun]));
              setBeingStunnedIndex(null);
              setShowCounterattack(false);
              setIsMonsterAttacking(false);
              setRoundStarted(false);
              setSelectedIndices(new Set());
              setRerollsLeft(playerState.baseRerolls);
            }, 800);
          } else {
            setShowCounterattack(false);
            setIsMonsterAttacking(false);
            setRoundStarted(false);
            setSelectedIndices(new Set());
            setRerollsLeft(playerState.baseRerolls);
          }
        }, 500);
      }, [stunnedIndices, totalDiceCount, effectiveMaxRerolls, playerState]);

      const handleMonsterDefeated = useCallback(() => {
        // Í≥®Îìú ÌöçÎìù
        setPlayerState(prevState => ({
          ...prevState,
          gold: prevState.gold + 3
        }));
        
        if (playerState.currentStage >= STAGES.length) {
          setShowVictory(true);
          triggerVictoryConfetti();
        } else {
          // ÏùºÎ∞ò Î≥¥ÏÉÅ Ï§ëÏóêÏÑú ÎûúÎç§ÏúºÎ°ú 3Í∞ú ÏÑ†ÌÉù (Ïù¥ÎØ∏ Íµ¨Îß§Ìïú Í≤É Ï†úÏô∏)
          const stackItemIds = ["dice_plus_one_stack", "dice_flip_stack"];
          const randomRegularRewards = getRandomRewards(3, [
            ...playerState.ownedRewards,
            ...stackItemIds
          ]);
          
          // Ï£ºÏÇ¨ÏúÑ Ïä§ÌÉù ÏïÑÏù¥ÌÖú Ï§ë ÌïòÎÇòÎßå ÎûúÎç§ ÏÑ†ÌÉù
          const stackRewards = [];
          const plusOneStack = REWARDS.find(r => r.id === "dice_plus_one_stack");
          const flipStack = REWARDS.find(r => r.id === "dice_flip_stack");
          
          // ÏµúÎåÄ Ïä§ÌÉùÏù¥ ÏïÑÎãàÎ©¥ ÏÑ†ÌÉù ÎåÄÏÉÅÏóê Ï∂îÍ∞Ä
          if (plusOneStack && playerState.dicePlusOneStacks < 3) {
            stackRewards.push(plusOneStack);
          }
          if (flipStack && playerState.diceFlipStacks < 3) {
            stackRewards.push(flipStack);
          }
          
          const randomStackReward = stackRewards.length > 0 
            ? [stackRewards[Math.floor(Math.random() * stackRewards.length)]]
            : [];
          
          // ÏùºÎ∞ò Î≥¥ÏÉÅÍ≥º Ïä§ÌÉù Î≥¥ÏÉÅÏùÑ Ìï©Ï≥êÏÑú ÌëúÏãú
          const finalRewards = [...randomRegularRewards, ...randomStackReward];
          setRewardOptions(finalRewards);
          setShowRewardSelection(true);
        }
      }, [playerState.currentStage, playerState.ownedRewards, playerState.dicePlusOneStacks, playerState.diceFlipStacks]);

      const executeAttack = useCallback((dice) => {
        setIsPlayerAttacking(true);
        const score = calculateScore(dice, { 
          ownedRewards: playerState.ownedRewards,
          monsterHp: monsterHp,
          maxMonsterHp: currentStage.hp,
          diceEnhancements: playerState.diceEnhancements || []
        });
        setAttackResult(score);
        setShowAttackResult(true);
        if (!score.isCursed) triggerConfetti(score);
        
        setTimeout(() => {
          setIsPlayerAttacking(false);
        }, 600);
        
        const newHp = Math.max(0, monsterHp - score.total);
        setTimeout(() => {
          setLastDamage(score.total);
          setShowDamage(true);
          setMonsterHp(newHp);
          setTimeout(() => setShowDamage(false), 1000);
        }, 800);
        
        setTimeout(() => {
          setShowAttackResult(false);
          setAttackResult(null);
          if (newHp <= 0) {
            setRoundStarted(false);
            setSelectedIndices(new Set());
            setRerollsLeft(effectiveMaxRerolls);
            handleMonsterDefeated();
          } else {
            executeCounterattack();
          }
        }, 2000);
      }, [monsterHp, currentStage, executeCounterattack, playerState.ownedRewards, effectiveMaxRerolls, handleMonsterDefeated]);

      const rollCustomDice = useCallback(() => {
        const forceFullReroll = playerState.holdDisabled;
        return playerState.diceTypes.map((type, idx) => {
          const isStunned = stunnedIndices.has(idx);
          if (forceFullReroll || selectedIndices.has(idx) || isStunned) {
            return rollDieByType(type, isStunned);
          }
          return currentDice[idx];
        });
      }, [playerState.diceTypes, playerState.holdDisabled, selectedIndices, stunnedIndices, currentDice]);

      const handleInitialRoll = () => {
        setSelectedIndices(new Set());
        setRerollsLeft(effectiveMaxRerolls);
        setRoundStarted(true);
        setShowAttackResult(false);
        setAttackResult(null);
        
        // Î™®Îì† Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î¶¨Îäî Ï§ëÏúºÎ°ú ÏÑ§Ï†ï
        setIsRolling(true);
        setRollingDice(new Set(Array.from({ length: totalDiceCount }, (_, i) => i)));
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Ï£ºÏÇ¨ÏúÑ Í∞í ÏóÖÎç∞Ïù¥Ìä∏
        setTimeout(() => {
          const newDice = playerState.diceTypes.map((type, idx) => {
            const isStunned = stunnedIndices.has(idx);
            return rollDieByType(type, isStunned);
          });
          setCurrentDice(newDice);
          setIsRolling(false);
          setRollingDice(new Set());
        }, 600);
      };

      const handleReroll = () => {
        if (rerollsLeft <= 0) return;
        
        // Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î¶¨Îäî Ï§ëÏúºÎ°ú ÏÑ§Ï†ï
        const forceFullReroll = playerState.holdDisabled;
        const diceToRoll = new Set();
        playerState.diceTypes.forEach((type, idx) => {
          const isStunned = stunnedIndices.has(idx);
          if (forceFullReroll || selectedIndices.has(idx) || isStunned) {
            diceToRoll.add(idx);
          }
        });
        
        // Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÍ∞Ä ÏóÜÍ≥† Í∞ïÏ†ú Î¶¨Î°§Ïù¥ ÏïÑÎãå Í≤ΩÏö∞ Í≤ΩÍ≥† ÌëúÏãú
        if (!forceFullReroll && diceToRoll.size === 0) {
          setShowRerollWarning(true);
          setTimeout(() => {
            setShowRerollWarning(false);
          }, 2000);
          return;
        }
        
        setIsRolling(true);
        setRollingDice(diceToRoll);
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Ï£ºÏÇ¨ÏúÑ Í∞í ÏóÖÎç∞Ïù¥Ìä∏
        setTimeout(() => {
          const newDice = rollCustomDice();
          setCurrentDice(newDice);
          setSelectedIndices(new Set());
          setRerollsLeft(prev => prev - 1);
          setIsRolling(false);
          setRollingDice(new Set());
        }, 600);
      };

      const handlePurchaseReward = (reward) => {
        // Í≥®Îìú ÌôïÏù∏
        if (playerState.gold < reward.price) {
          return; // Í≥®Îìú Î∂ÄÏ°±
        }
        
        // Ïä§ÌÉù Íµ¨Îß§ ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
        if (reward.id === "dice_plus_one_stack") {
          if (playerState.dicePlusOneStacks >= 3) {
            return; // ÏµúÎåÄ Ïä§ÌÉù ÎèÑÎã¨
          }
          const newState = { ...playerState };
          newState.gold -= reward.price;
          newState.dicePlusOneStacks += 1;
          setPlayerState(newState);
          return;
        }
        
        if (reward.id === "dice_flip_stack") {
          if (playerState.diceFlipStacks >= 3) {
            return; // ÏµúÎåÄ Ïä§ÌÉù ÎèÑÎã¨
          }
          const newState = { ...playerState };
          newState.gold -= reward.price;
          newState.diceFlipStacks += 1;
          setPlayerState(newState);
          return;
        }
        
        // Ïù¥ÎØ∏ Íµ¨Îß§Ìïú Î≥¥ÏÉÅÏù∏ÏßÄ ÌôïÏù∏
        if (playerState.ownedRewards.includes(reward.id)) {
          return; // Ïù¥ÎØ∏ Íµ¨Îß§Ìï®
        }
        
        // Í≥®Îìú Ï∞®Í∞ê Î∞è Î≥¥ÏÉÅ Ï†ÅÏö©
        const newState = applyReward(playerState, reward.id);
        newState.gold -= reward.price;
        setPlayerState(newState);
      };

      const handleNextStage = () => {
        const newState = { ...playerState };
        newState.currentStage += 1;
        // Í∞ïÏ≤† Ïô∏Ìîº: ÏÉà Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú Ï≤´ Í≥µÍ≤© Î¨¥Ìö®Ìôî Í∞ÄÎä•ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
        if (newState.ownedRewards.includes("steel_armor")) {
          newState.firstAttackBlocked = true;
        }
        
        // Ï£ºÏÇ¨ÏúÑ Í∞úÏàò Î≥ÄÍ≤Ω Ïãú diceEnhancements Î∞∞Ïó¥ ÌÅ¨Í∏∞ Ï°∞Ï†ï
        const newDiceCount = newState.diceTypes.length;
        const currentEnhancements = newState.diceEnhancements || [];
        if (currentEnhancements.length !== newDiceCount) {
          if (newDiceCount > currentEnhancements.length) {
            // Ï£ºÏÇ¨ÏúÑÍ∞Ä ÎäòÏñ¥ÎÇú Í≤ΩÏö∞: Í∏∞Ï°¥ Í∞ïÌôî Î†àÎ≤® Ïú†ÏßÄ, ÏÉà Ï£ºÏÇ¨ÏúÑÎäî 0
            newState.diceEnhancements = [...currentEnhancements, ...Array(newDiceCount - currentEnhancements.length).fill(0)];
          } else {
            // Ï£ºÏÇ¨ÏúÑÍ∞Ä Ï§ÑÏñ¥Îì† Í≤ΩÏö∞: ÏïûÎ∂ÄÎ∂ÑÎßå Ïú†ÏßÄ
            newState.diceEnhancements = currentEnhancements.slice(0, newDiceCount);
          }
        }
        
        setPlayerState(newState);
        setShowRewardSelection(false);
        setStunnedIndices(new Set());
        setRerollsLeft(newState.baseRerolls);
        if (newState.diceTypes.length > currentDice.length) {
          setCurrentDice(Array.from({ length: newDiceCount }, (_, i) => i + 1));
        } else {
          // Ï£ºÏÇ¨ÏúÑ Í∞úÏàòÍ∞Ä Í∞ôÏïÑÎèÑ ÏàúÏÑúÎåÄÎ°ú ÌëúÏãú
          setCurrentDice(Array.from({ length: newDiceCount }, (_, i) => i + 1));
        }
        const nextStage = STAGES[newState.currentStage - 1];
        if (nextStage) setMonsterHp(nextStage.hp);
      };

      const handleRestart = () => {
        const initialState = getInitialPlayerState();
        setPlayerState(initialState);
        const initialDiceCount = initialState.diceTypes.length;
        setCurrentDice(Array.from({ length: initialDiceCount }, (_, i) => i + 1));
        setSelectedIndices(new Set());
        setRerollsLeft(initialState.baseRerolls);
        setRoundStarted(false);
        setStunnedIndices(new Set());
        setMonsterHp(STAGES[0].hp);
        setShowVictory(false);
        setShowRewardSelection(false);
      };

      const canReroll = roundStarted && rerollsLeft > 0 && !showAttackResult && !showCounterattack;
      const canAttack = roundStarted && !showAttackResult && !showCounterattack;
      const isMonsterDefeated = monsterHp <= 0;
      const allDiceStunned = normalDiceCount <= 0;

      return (
        <div className="container">
          <main className="main-game">
            <div className="bg-decoration bg-1" />
            <div className="bg-decoration bg-2" />
            
            <div className="stage-indicator">
              <span className="stage-badge">Stage {playerState.currentStage} / 9</span>
              <div className="gold-display">
                <span className="gold-icon">ü™ô</span>
                <span>{playerState.gold}</span>
              </div>
              {(playerState.dicePlusOneStacks > 0 || playerState.diceFlipStacks > 0 || (playerState.diceEnhanceCharges || 0) > 0) && (
                <div style={{ 
                  display: 'flex', 
                  gap: '0.5rem', 
                  alignItems: 'center',
                  marginLeft: '0.5rem'
                }}>
                  {playerState.dicePlusOneStacks > 0 && (
                    <div style={{
                      background: 'linear-gradient(135deg, #10b981, #059669)',
                      color: 'white',
                      padding: '0.25rem 0.75rem',
                      borderRadius: '9999px',
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '0.25rem'
                    }}>
                      <span>üìà</span>
                      <span>{playerState.dicePlusOneStacks}</span>
                    </div>
                  )}
                  {playerState.diceFlipStacks > 0 && (
                    <div style={{
                      background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
                      color: 'white',
                      padding: '0.25rem 0.75rem',
                      borderRadius: '9999px',
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '0.25rem'
                    }}>
                      <span>üîÑ</span>
                      <span>{playerState.diceFlipStacks}</span>
                    </div>
                  )}
                  {(playerState.diceEnhanceCharges || 0) > 0 && (
                    <div style={{
                      background: 'linear-gradient(135deg, #fbbf24, #f59e0b)',
                      color: 'white',
                      padding: '0.25rem 0.75rem',
                      borderRadius: '9999px',
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '0.25rem'
                    }}>
                      <span>‚≠ê</span>
                      <span>{playerState.diceEnhanceCharges || 0}</span>
                    </div>
                  )}
                </div>
              )}
              <button 
                className="btn" 
                onClick={() => setShowMonsterPreview(true)}
                style={{ 
                  marginLeft: '1rem', 
                  padding: '0.5rem 1rem', 
                  fontSize: '0.875rem',
                  background: 'rgba(99, 102, 241, 0.1)',
                  border: '1px solid rgba(99, 102, 241, 0.3)'
                }}
              >
                Î™¨Ïä§ÌÑ∞ ÎØ∏Î¶¨Î≥¥Í∏∞
              </button>
            </div>
            
            <div className="monster-section">
              <Monster name={currentStage.name} nameKo={currentStage.nameKo} maxHp={currentStage.hp} currentHp={monsterHp} showDamage={showDamage} damage={lastDamage} isMonsterAttacking={isMonsterAttacking} imageUrl={currentStage.imageUrl} />
            </div>

            {showMonsterPreview && (
              <div className="modal-overlay" onClick={() => setShowMonsterPreview(false)}>
                <div className="modal" onClick={(e) => e.stopPropagation()} style={{ maxWidth: '900px', maxHeight: '90vh', overflow: 'auto' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                    <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>Î™¨Ïä§ÌÑ∞ ÎØ∏Î¶¨Î≥¥Í∏∞</h2>
                    <button 
                      className="btn" 
                      onClick={() => setShowMonsterPreview(false)}
                      style={{ padding: '0.5rem 1rem' }}
                    >
                      Îã´Í∏∞
                    </button>
                  </div>
                  <div style={{ 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', 
                    gap: '2rem',
                    padding: '1rem'
                  }}>
                    {STAGES.map(stage => (
                      <div key={stage.id} style={{ 
                        display: 'flex', 
                        flexDirection: 'column', 
                        alignItems: 'center',
                        background: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '1rem',
                        padding: '1.5rem'
                      }}>
                        <Monster 
                          name={stage.name} 
                          nameKo={stage.nameKo} 
                          maxHp={stage.hp} 
                          currentHp={stage.hp} 
                          showDamage={false} 
                          damage={0} 
                          isMonsterAttacking={false} 
                          imageUrl={stage.imageUrl} 
                        />
                        <div style={{ marginTop: '0.5rem', fontSize: '0.875rem', color: 'rgba(255,255,255,0.8)' }}>
                          Stage {stage.id}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {showVictory && (
              <div className="modal-overlay" onClick={handleRestart}>
                <div className="modal">
                  <h2 style={{ fontSize: '2rem', fontWeight: 'bold', marginBottom: '1rem' }}>üéâ ÏäπÎ¶¨! üéâ</h2>
                  <p style={{ marginBottom: '1.5rem' }}>Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄÎ•º ÌÅ¥Î¶¨Ïñ¥ÌñàÏäµÎãàÎã§!</p>
                  <button className="btn btn-attack" onClick={handleRestart}>Îã§Ïãú ÏãúÏûë</button>
                </div>
              </div>
            )}

            {showRewardSelection && (
              <div className="modal-overlay">
                <div className="modal" style={{ maxWidth: '700px', maxHeight: '90vh', overflow: 'auto' }}>
                  <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>üõí ÏÉÅÏ†ê</h2>
                  <div style={{ marginBottom: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.5rem' }}>
                    <span className="gold-icon">ü™ô</span>
                    <span style={{ fontSize: '1.125rem', fontWeight: 'bold' }}>Î≥¥Ïú† Í≥®Îìú: {playerState.gold}</span>
                  </div>
                  <div style={{ 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', 
                    gap: '1rem',
                    marginBottom: '1.5rem'
                  }}>
                    {rewardOptions.map(reward => {
                      // Ïä§ÌÉù Íµ¨Îß§ ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
                      const isStackItem = reward.id === "dice_plus_one_stack" || reward.id === "dice_flip_stack";
                      let currentStacks = 0;
                      let maxStacks = 3;
                      if (reward.id === "dice_plus_one_stack") {
                        currentStacks = playerState.dicePlusOneStacks;
                      } else if (reward.id === "dice_flip_stack") {
                        currentStacks = playerState.diceFlipStacks;
                      }
                      
                      const isOwned = !isStackItem && playerState.ownedRewards.includes(reward.id);
                      const canAfford = playerState.gold >= reward.price;
                      const isMaxStacks = isStackItem && currentStacks >= maxStacks;
                      const canPurchase = isStackItem 
                        ? !isMaxStacks && canAfford 
                        : !isOwned && canAfford;
                      
                      return (
                        <div 
                          key={reward.id} 
                          className="reward-option" 
                          style={{
                            opacity: (isOwned || isMaxStacks) ? 0.6 : 1,
                            cursor: canPurchase ? 'pointer' : 'not-allowed',
                            background: (isOwned || isMaxStacks)
                              ? 'rgba(100, 100, 100, 0.2)' 
                              : canPurchase 
                                ? 'rgba(255, 255, 255, 0.1)' 
                                : 'rgba(100, 100, 100, 0.1)'
                          }}
                        >
                          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '0.5rem' }}>
                            <div style={{ fontWeight: 'bold', fontSize: '1rem' }}>{reward.nameKo}</div>
                            <div style={{ 
                              display: 'flex', 
                              alignItems: 'center', 
                              gap: '0.25rem',
                              color: canAfford ? '#fbbf24' : '#ef4444'
                            }}>
                              <span>ü™ô</span>
                              <span style={{ fontWeight: 'bold' }}>{reward.price}</span>
                            </div>
                          </div>
                          <div style={{ fontSize: '0.875rem', color: 'rgba(255,255,255,0.9)', marginBottom: '0.75rem' }}>
                            {reward.descriptionKo}
                            {isStackItem && (
                              <div style={{ marginTop: '0.5rem', fontWeight: 'bold', color: currentStacks >= maxStacks ? '#ef4444' : '#fbbf24' }}>
                                ÌòÑÏû¨: {currentStacks} / {maxStacks} Ïä§ÌÉù
                              </div>
                            )}
                          </div>
                          {isOwned ? (
                            <div style={{ 
                              textAlign: 'center', 
                              padding: '0.5rem', 
                              background: 'rgba(100, 100, 100, 0.3)',
                              borderRadius: '0.5rem',
                              fontSize: '0.875rem',
                              fontWeight: 'bold'
                            }}>
                              Íµ¨Îß§ ÏôÑÎ£å
                            </div>
                          ) : isMaxStacks ? (
                            <div style={{ 
                              textAlign: 'center', 
                              padding: '0.5rem', 
                              background: 'rgba(239, 68, 68, 0.3)',
                              borderRadius: '0.5rem',
                              fontSize: '0.875rem',
                              fontWeight: 'bold',
                              color: '#fee2e2'
                            }}>
                              ÏµúÎåÄ Ïä§ÌÉù ÎèÑÎã¨
                            </div>
                          ) : (
                            <button
                              className="btn"
                              onClick={() => handlePurchaseReward(reward)}
                              disabled={!canPurchase}
                              style={{
                                width: '100%',
                                padding: '0.75rem',
                                fontSize: '0.875rem',
                                background: canPurchase 
                                  ? 'linear-gradient(to right, #fbbf24, #f59e0b)' 
                                  : 'rgba(100, 100, 100, 0.5)',
                                cursor: canPurchase ? 'pointer' : 'not-allowed'
                              }}
                            >
                              {canAfford ? (isStackItem ? 'Ïä§ÌÉù Íµ¨Îß§' : 'Íµ¨Îß§ÌïòÍ∏∞') : 'Í≥®Îìú Î∂ÄÏ°±'}
                            </button>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  <button 
                    className="btn btn-attack" 
                    onClick={handleNextStage}
                    style={{ width: '100%', marginTop: '1rem' }}
                  >
                    Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄÎ°ú
                  </button>
                </div>
              </div>
            )}

            {showCounterattack && (
              <div className="counterattack-overlay">
                <div className="counterattack-modal">
                  ‚ö° Î∞òÍ≤©! ‚ö°<br />
                  <div style={{ fontSize: '1rem', marginTop: '0.5rem', opacity: 0.9 }}>‚ö† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÌï©ÎãàÎã§...</div>
                </div>
              </div>
            )}

            {showRerollWarning && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal" style={{ background: 'linear-gradient(to right, #f59e0b, #f97316)', maxWidth: '350px', padding: '1.5rem' }}>
                  <div style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>‚ö† Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>
                </div>
              </div>
            )}

            {showDiceModifyWarning && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal" style={{ background: 'linear-gradient(to right, #ef4444, #dc2626)', maxWidth: '350px', padding: '1.5rem' }}>
                  <div style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>‚ö† Ï£ºÏÇ¨ÏúÑÎ•º 1Í∞úÎßå ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî</div>
                </div>
              </div>
            )}

            {showAttackResult && attackResult && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal attack-result-modal" style={{ background: attackResult.isCursed ? 'linear-gradient(to right, #374151, #111827)' : `linear-gradient(to right, #6366f1, #7c3aed)` }}>
                  <div className="attack-label" style={{ fontWeight: 'bold', marginBottom: '0.5rem' }}>
                    {attackResult.isCursed ? 'CURSED!' : attackResult.labelKo.replace(/\s*\([^)]*\)/g, '')}!
                  </div>
                  <div className="attack-result" style={{ fontSize: '1.5rem' }}>
                    {attackResult.sum} √ó {attackResult.multiplier * attackResult.finalMultiplier} = {attackResult.total}
                  </div>
                </div>
              </div>
            )}

            <h1 className="title">Dice<span style={{ color: '#6366f1' }}>Battle</span></h1>
            <p className="subtitle">
              {!roundStarted ? "Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î†§ Î™¨Ïä§ÌÑ∞Î•º Í≥µÍ≤©ÌïòÏÑ∏Ïöî!" : playerState.holdDisabled ? "Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Î¶¨Î°§Îê©ÎãàÎã§! Í≥µÍ≤©ÌïòÏÑ∏Ïöî!" : "Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º ÏÑ†ÌÉùÌïòÍ±∞ÎÇò Í≥µÍ≤©ÌïòÏÑ∏Ïöî!"}
            </p>

            {stunnedDiceCount > 0 && (
              <div className="stun-counter">
                ‚ö† Í∏∞Ï†àÎêú Ï£ºÏÇ¨ÏúÑ: {stunnedDiceCount} / {totalDiceCount}
                <div className="stun-tooltip">
                  Í∏∞Ï†àÎêú Ï£ºÏÇ¨ÏúÑÎäî 1,1,1,0,0,0 ÎààÍ∏àÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÍ≥† Î¶¨Î°§Ïãú Ïû¨Íµ¥Î¶ºÎê©ÎãàÎã§. Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÎêòÎ©¥ Ìå®Î∞∞Ìï©ÎãàÎã§.
                </div>
              </div>
            )}

            <div className={`dice-container ${isPlayerAttacking ? 'attacking' : ''}`}>
              {isPlayerAttacking && (
                <div className="attack-effect">
                  <div className="attack-flash" />
                </div>
              )}
              {currentDice.map((value, idx) => (
                <Die
                  key={idx}
                  index={idx}
                  value={value}
                  isSelected={selectedIndices.has(idx)}
                  isStunned={stunnedIndices.has(idx)}
                  isRolling={isRolling && rollingDice.has(idx)}
                  diceType={playerState.diceTypes[idx] || "normal"}
                  onToggle={() => toggleSelect(idx)}
                  selectionDisabled={playerState.holdDisabled}
                  enhancementLevel={(playerState.diceEnhancements || [0, 0, 0, 0, 0])[idx] || 0}
                />
              ))}
            </div>

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && selectedIndices.size > 0 && (
              <div style={{ 
                display: 'flex', 
                justifyContent: 'center', 
                gap: '1rem', 
                marginTop: '1rem',
                flexWrap: 'wrap'
              }}>
                {playerState.dicePlusOneStacks > 0 && (
                  <button
                    className="btn"
                    onClick={() => {
                      // Ï£ºÏÇ¨ÏúÑÍ∞Ä 1Í∞úÎßå ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
                      if (selectedIndices.size > 1) {
                        setShowDiceModifyWarning(true);
                        setTimeout(() => {
                          setShowDiceModifyWarning(false);
                        }, 2000);
                        return;
                      }
                      
                      const newDice = [...currentDice];
                      selectedIndices.forEach(idx => {
                        if (newDice[idx] > 0 && newDice[idx] < 6) {
                          newDice[idx] = newDice[idx] + 1;
                        } else if (newDice[idx] === 0) {
                          newDice[idx] = 1;
                        }
                      });
                      setCurrentDice(newDice);
                      setSelectedIndices(new Set());
                      // Ïä§ÌÉù Ï∞®Í∞ê
                      setPlayerState(prevState => ({
                        ...prevState,
                        dicePlusOneStacks: prevState.dicePlusOneStacks - 1
                      }));
                    }}
                    style={{
                      background: 'linear-gradient(to right, #10b981, #059669)',
                      padding: '0.75rem 1.5rem',
                      fontSize: '0.875rem'
                    }}
                  >
                    üìà ÏÑ†ÌÉùÌïú Ï£ºÏÇ¨ÏúÑ +1 ({playerState.dicePlusOneStacks}Ìöå ÎÇ®Ïùå)
                  </button>
                )}
                {playerState.diceFlipStacks > 0 && (
                  <button
                    className="btn"
                    onClick={() => {
                      // Ï£ºÏÇ¨ÏúÑÍ∞Ä 1Í∞úÎßå ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
                      if (selectedIndices.size > 1) {
                        setShowDiceModifyWarning(true);
                        setTimeout(() => {
                          setShowDiceModifyWarning(false);
                        }, 2000);
                        return;
                      }
                      
                      const newDice = [...currentDice];
                      selectedIndices.forEach(idx => {
                        if (newDice[idx] > 0 && newDice[idx] <= 6) {
                          newDice[idx] = 7 - newDice[idx];
                        }
                      });
                      setCurrentDice(newDice);
                      setSelectedIndices(new Set());
                      // Ïä§ÌÉù Ï∞®Í∞ê
                      setPlayerState(prevState => ({
                        ...prevState,
                        diceFlipStacks: prevState.diceFlipStacks - 1
                      }));
                    }}
                    style={{
                      background: 'linear-gradient(to right, #8b5cf6, #7c3aed)',
                      padding: '0.75rem 1.5rem',
                      fontSize: '0.875rem'
                    }}
                  >
                    üîÑ ÏÑ†ÌÉùÌïú Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ ({playerState.diceFlipStacks}Ìöå ÎÇ®Ïùå)
                  </button>
                )}
                {(playerState.diceEnhanceCharges || 0) > 0 && (
                  <button
                    className="btn"
                    onClick={() => {
                      // Ï£ºÏÇ¨ÏúÑÍ∞Ä 1Í∞úÎßå ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
                      if (selectedIndices.size > 1) {
                        setShowDiceModifyWarning(true);
                        setTimeout(() => {
                          setShowDiceModifyWarning(false);
                        }, 2000);
                        return;
                      }
                      
                      // ÏÑ†ÌÉùÌïú Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî
                      const selectedIndex = Array.from(selectedIndices)[0];
                      const newEnhancements = [...(playerState.diceEnhancements || [0, 0, 0, 0, 0])];
                      newEnhancements[selectedIndex] = (newEnhancements[selectedIndex] || 0) + 1;
                      
                      setPlayerState(prevState => ({
                        ...prevState,
                        diceEnhancements: newEnhancements,
                        diceEnhanceCharges: (prevState.diceEnhanceCharges || 0) - 1
                      }));
                      setSelectedIndices(new Set());
                    }}
                    style={{
                      background: 'linear-gradient(to right, #fbbf24, #f59e0b)',
                      padding: '0.75rem 1.5rem',
                      fontSize: '0.875rem'
                    }}
                  >
                    ‚≠ê Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî ({playerState.diceEnhanceCharges || 0}Ìöå ÎÇ®Ïùå)
                    {selectedIndices.size === 1 && (() => {
                      const selectedIdx = Array.from(selectedIndices)[0];
                      const currentEnhance = (playerState.diceEnhancements || [0, 0, 0, 0, 0])[selectedIdx] || 0;
                      return ` (ÌòÑÏû¨: +${currentEnhance})`;
                    })()}
                  </button>
                )}
              </div>
            )}

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
              <div className="score-preview">
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginBottom: '0.5rem' }}>ÌòÑÏû¨ Ï°∞Ìï© ({totalDiceCount} Ï£ºÏÇ¨ÏúÑ)</div>
                <div style={{ fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '0.25rem', color: currentScore.isCursed ? '#6b7280' : '#6366f1' }}>
                  {currentScore.isCursed ? 'CURSED!' : currentScore.label}
                </div>
                <div style={{ fontSize: '0.875rem', color: '#64748b', marginBottom: '0.5rem' }}>{currentScore.labelKo}</div>
                <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#1e293b' }}>
                  {currentScore.sum} √ó{currentScore.multiplier}
                  {currentScore.finalMultiplier > 1 && <span style={{ color: '#f59e0b' }}> √ó{currentScore.finalMultiplier}</span>}
                  {' = '}
                  <span style={{ fontSize: '1.5rem' }}>{currentScore.total}</span>
                </div>
              </div>
            )}

            {allDiceStunned && !isMonsterDefeated && (
              <div style={{ textAlign: 'center', marginBottom: '1rem' }}>
                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#dc2626', marginBottom: '0.5rem' }}>Ìå®Î∞∞!</div>
                <div style={{ color: '#475569', marginBottom: '1rem' }}>‚ö† Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÌñàÏäµÎãàÎã§.</div>
                <button className="btn btn-attack" onClick={handleRestart}>Îã§Ïãú ÏãúÏûë</button>
              </div>
            )}

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
              <div className="rerolls-left">ÎÇ®ÏùÄ Î¶¨Î°§: {rerollsLeft}</div>
            )}

            <div className="controls">
              {!roundStarted && !isMonsterDefeated && !allDiceStunned && !showRewardSelection && !showVictory && (
                <button className="btn btn-roll" onClick={handleInitialRoll}>Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞</button>
              )}
              {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
                <>
                  <button className="btn btn-reroll" onClick={handleReroll} disabled={!canReroll}>
                    Î¶¨Î°§ ({rerollsLeft})
                  </button>
                  <button className="btn btn-attack" onClick={() => executeAttack(currentDice)} disabled={!canAttack}>
                    Í≥µÍ≤©!
                  </button>
                </>
              )}
            </div>

            {playerState.ownedRewards.length > 0 && (
              <div className="owned-rewards">
                {playerState.ownedRewards.map(rewardId => {
                  const reward = REWARDS.find(r => r.id === rewardId);
                  if (!reward) return null;
                  return (
                    <span key={rewardId} className="reward-badge" title={reward.descriptionKo}>
                      {reward.nameKo}
                    </span>
                  );
                })}
              </div>
            )}
          </main>

          <aside className="sidebar">
            <div className="guide-card">
              <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem' }}>Ï°±Î≥¥ Í∞ÄÏù¥Îìú</h2>
              {Object.entries(COMBINATIONS).map(([key, combo]) => {
                let displayMultiplier = combo.multiplier;
                // Í∞ïÌôî Î≥¥ÏÉÅ Ï†ÅÏö©
                if (key === "chance" && playerState.ownedRewards.includes("gamblers_chip")) {
                  displayMultiplier = 2;
                } else if (key === "threeOfAKind" && playerState.ownedRewards.includes("triple_boost")) {
                  displayMultiplier = 3;
                } else if (key === "twoPair" && playerState.ownedRewards.includes("two_pair_boost")) {
                  displayMultiplier = 4;
                } else if (key === "smallStraight" && playerState.ownedRewards.includes("small_straight_boost")) {
                  displayMultiplier = 5;
                } else if (key === "fullHouse" && playerState.ownedRewards.includes("full_house_boost")) {
                  displayMultiplier = 8;
                }
                const isBoosted = displayMultiplier !== combo.multiplier;
                return (
                  <div key={key} className="guide-item">
                    <span>{combo.labelKo}</span>
                    <span style={{ fontWeight: 'bold', color: isBoosted ? '#fbbf24' : 'inherit' }}>
                      √ó{displayMultiplier}
                      {isBoosted && <span style={{ fontSize: '0.75rem', marginLeft: '0.25rem' }}>‚ú®</span>}
                    </span>
                  </div>
                );
              })}
              <div style={{ marginTop: '0.75rem', fontSize: '0.75rem', color: 'rgba(255,255,255,0.8)' }}>
                Îç∞ÎØ∏ÏßÄ = Ìï©Í≥Ñ √ó Î∞∞Ïàò √ó Î≥¥ÏÉÅ
              </div>
            </div>
          </aside>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Game />);
  </script>
</body>
</html>