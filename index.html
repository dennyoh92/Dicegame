<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dice Battle - Ï£ºÏÇ¨ÏúÑ Ï†ÑÌà¨ Í≤åÏûÑ</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background: radial-gradient(ellipse at top, #eef2ff 0%, #f8fafc 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    @media (max-width: 768px) {
      body {
        padding: 0.25rem;
      }
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 2rem;
      padding: 2rem;
    }
    @media (max-width: 1024px) {
      .container { 
        grid-template-columns: 1fr;
        padding: 0.75rem;
        gap: 0.75rem;
      }
    }
    @media (max-width: 768px) {
      .container {
        padding: 0.25rem;
        gap: 0.5rem;
      }
    }
    .main-game {
      background: rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(12px);
      border-radius: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 20px 25px -5px rgba(99, 102, 241, 0.1);
      padding: 2rem;
      min-height: 750px;
      position: relative;
      overflow: hidden;
    }
    @media (max-width: 768px) {
      .main-game {
        padding: 0.75rem;
        border-radius: 1rem;
        min-height: auto;
      }
    }
    .bg-decoration {
      position: absolute;
      border-radius: 50%;
      filter: blur(60px);
      pointer-events: none;
    }
    .bg-1 { top: 0; left: 0; width: 256px; height: 256px; background: rgba(129, 140, 248, 0.1); transform: translate(-50%, -50%); }
    .bg-2 { bottom: 0; right: 0; width: 384px; height: 384px; background: rgba(249, 168, 212, 0.1); transform: translate(33%, 33%); }
    .title {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 2.5rem;
      font-weight: bold;
      color: #1e293b;
    }
    @media (max-width: 768px) {
      .title {
        font-size: 1.75rem;
        margin-bottom: 0.5rem;
      }
    }
    .subtitle {
      text-align: center;
      font-size: 0.875rem;
      color: #64748b;
      margin-bottom: 1rem;
    }
    .stage-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .stage-badge {
      background: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      font-weight: bold;
    }
    .monster-section {
      margin-bottom: 1rem;
    }
    .monster-container {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    @media (max-width: 768px) {
      .monster-container {
        padding: 0.75rem;
        min-height: 200px;
      }
    }
    .monster-body {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1rem;
      transition: transform 0.3s ease;
      overflow: visible;
      width: 100%;
      max-width: 100%;
    }
    @media (max-width: 768px) {
      .monster-body {
        margin-bottom: 0.5rem;
      }
    }
    .monster-image {
      width: 200px;
      height: 200px;
      object-fit: contain;
    }
    .monster-image-sprite {
      width: 200px;
      height: 200px;
      background-repeat: no-repeat;
    }
    @media (max-width: 768px) {
      .monster-image {
        width: 140px;
        height: 140px;
      }
      .monster-image-sprite {
        width: 140px;
        height: 140px;
      }
    }
    .monster-body.attacking {
      animation: monsterAttack 0.5s ease-out;
    }
    @keyframes monsterAttack {
      0% { transform: translateX(0) scale(1); }
      50% { transform: translateX(30px) scale(1.1); }
      100% { transform: translateX(0) scale(1); }
    }
    .dice-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
      position: relative;
    }
    @media (max-width: 768px) {
      .dice-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.75rem;
        max-width: 220px;
        margin-left: auto;
        margin-right: auto;
      }
    }
    .dice-container.attacking {
      animation: playerAttack 0.6s ease-out;
    }
    @keyframes playerAttack {
      0% { transform: translateY(0); }
      30% { transform: translateY(-20px) scale(1.1); }
      60% { transform: translateY(-10px) scale(1.05); }
      100% { transform: translateY(0) scale(1); }
    }
    .attack-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    .attack-flash {
      position: absolute;
      inset: -20px;
      background: radial-gradient(circle, rgba(239, 68, 68, 0.3) 0%, transparent 70%);
      border-radius: 50%;
      animation: attackFlash 0.3s ease-out;
      opacity: 0;
    }
    @keyframes attackFlash {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }
    .monster-attack-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200%;
      height: 200%;
      pointer-events: none;
      z-index: 10;
    }
    .monster-attack-flash {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, rgba(245, 158, 11, 0.4) 0%, transparent 70%);
      border-radius: 50%;
      animation: monsterAttackFlash 0.4s ease-out;
      opacity: 0;
    }
    @keyframes monsterAttackFlash {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.3); opacity: 0; }
    }
    .monster-slime {
      width: 180px; height: 140px;
      position: relative;
      animation: slimeBounce 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes slimeBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-10px) scale(1.05); }
    }
    .monster-slime::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #bef264 0%, #84cc16 50%, #65a30d 100%);
      border-radius: 60% 60% 50% 50% / 70% 70% 30% 30%;
      box-shadow: 
        0 15px 30px rgba(34, 197, 94, 0.4),
        inset 0 -20px 40px rgba(22, 163, 74, 0.3),
        inset 0 20px 20px rgba(254, 255, 255, 0.2);
    }
    .monster-slime::after {
      content: '';
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 100px;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
      border-radius: 50%;
    }
    .slime-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 2;
    }
    .slime-eye {
      width: 24px;
      height: 32px;
      background: white;
      border-radius: 50%;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .slime-eye::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 6px;
      width: 12px;
      height: 16px;
      background: #1e293b;
      border-radius: 50%;
    }
    .slime-mouth {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      border: 3px solid #15803d;
      border-top: none;
      border-radius: 0 0 50% 50%;
    }
    .slime-bubbles {
      position: absolute;
      bottom: -10px;
      right: 20px;
      width: 12px;
      height: 12px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: bubbleFloat 3s ease-in-out infinite;
    }
    .slime-bubbles::after {
      content: '';
      position: absolute;
      bottom: 15px;
      right: 5px;
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: bubbleFloat 3s ease-in-out infinite 0.5s;
    }
    @keyframes bubbleFloat {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
      50% { transform: translateY(-15px) scale(1.2); opacity: 0.3; }
    }
    
    .monster-goblin {
      width: 160px; height: 200px;
      position: relative;
      animation: goblinSway 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes goblinSway {
      0%, 100% { transform: rotate(-2deg); }
      50% { transform: rotate(2deg); }
    }
    .monster-goblin::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 40%, #16a34a 100%);
      border-radius: 40% 50% 35% 45% / 50% 55% 40% 45%;
      box-shadow: 
        0 20px 40px rgba(34, 197, 94, 0.3),
        inset 0 -30px 50px rgba(21, 128, 61, 0.4),
        inset 0 10px 20px rgba(255, 255, 255, 0.15);
    }
    .goblin-ears {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 60px;
      z-index: 1;
    }
    .goblin-ear-left {
      position: absolute;
      left: 20px;
      top: 0;
      width: 32px;
      height: 42px;
      background: linear-gradient(135deg, #16a34a, #15803d);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-15deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .goblin-ear-left::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 10px;
      width: 14px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(34, 197, 94, 0.4), transparent);
      border-radius: 50%;
    }
    .goblin-ear-right {
      position: absolute;
      right: 20px;
      top: 0;
      width: 32px;
      height: 42px;
      background: linear-gradient(225deg, #16a34a, #15803d);
      border-radius: 0 50% 50% 50%;
      transform: rotate(15deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .goblin-ear-right::after {
      content: '';
      position: absolute;
      top: 12px;
      right: 10px;
      width: 14px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(34, 197, 94, 0.4), transparent);
      border-radius: 50%;
    }
    .goblin-eyes {
      position: absolute;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 2;
    }
    .goblin-eye {
      width: 32px;
      height: 36px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      border: 4px solid #ca8a04;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 0 15px rgba(250, 204, 21, 0.6);
      position: relative;
    }
    .goblin-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      width: 12px;
      height: 14px;
      background: #dc2626;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    .goblin-eye::after {
      content: '';
      position: absolute;
      top: 10px;
      left: 10px;
      width: 6px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
    }
    .goblin-nose {
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 24px;
      height: 22px;
      background: linear-gradient(to bottom, #22c55e, #16a34a);
      border-radius: 50%;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .goblin-mouth {
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 35px;
      background: linear-gradient(to top, #991b1b, #7f1d1d);
      border-radius: 0 0 50% 50% / 0 0 100% 100%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.6),
        0 2px 4px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-around;
      padding-top: 6px;
    }
    .goblin-tooth {
      width: 6px;
      height: 10px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    
    .monster-orc {
      width: 200px; height: 220px;
      position: relative;
      animation: orcBreathe 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes orcBreathe {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    .monster-orc::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #10b981 0%, #059669 50%, #047857 100%);
      border-radius: 30% 40% 25% 35% / 45% 50% 40% 45%;
      box-shadow: 
        0 25px 50px rgba(5, 150, 105, 0.4),
        inset 0 -40px 60px rgba(4, 120, 87, 0.5),
        inset 0 15px 30px rgba(255, 255, 255, 0.1);
    }
    .orc-ears {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 50px;
      z-index: 1;
    }
    .orc-ear-left {
      position: absolute;
      left: 25px;
      top: 0;
      width: 28px;
      height: 42px;
      background: linear-gradient(135deg, #047857, #065f46);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-15deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .orc-ear-left::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 10px;
      width: 12px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(5, 150, 105, 0.3), transparent);
      border-radius: 50%;
    }
    .orc-ear-right {
      position: absolute;
      right: 25px;
      top: 0;
      width: 28px;
      height: 42px;
      background: linear-gradient(225deg, #047857, #065f46);
      border-radius: 0 50% 50% 50%;
      transform: rotate(15deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.4);
    }
    .orc-ear-right::after {
      content: '';
      position: absolute;
      top: 12px;
      right: 10px;
      width: 12px;
      height: 18px;
      background: linear-gradient(to bottom, rgba(5, 150, 105, 0.3), transparent);
      border-radius: 50%;
    }
    .orc-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 45px;
      z-index: 2;
    }
    .orc-eye {
      width: 38px;
      height: 28px;
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border-radius: 50%;
      border: 5px solid #065f46;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.35),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .orc-eye::before {
      content: '';
      position: absolute;
      top: 5px;
      left: 7px;
      width: 14px;
      height: 14px;
      background: #b91c1c;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }
    .orc-eye::after {
      content: '';
      position: absolute;
      top: 6px;
      left: 8px;
      width: 6px;
      height: 6px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
    }
    .orc-nose {
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 28px;
      background: linear-gradient(to bottom, #047857, #065f46);
      border-radius: 50%;
      box-shadow: 
        inset 0 5px 10px rgba(0, 0, 0, 0.6),
        0 3px 6px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    .orc-tusks {
      position: absolute;
      top: 161px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 3;
    }
    .orc-tusk {
      width: 13px;
      height: 30px;
      background: linear-gradient(to bottom, #fef3c7, #fde68a);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        0 3px 6px rgba(0, 0, 0, 0.4),
        inset 0 -2px 4px rgba(217, 119, 6, 0.3);
    }
    .orc-tusk-left { transform: rotate(164deg); }
    .orc-tusk-right { transform: rotate(196deg); }
    .orc-mouth {
      position: absolute;
      bottom: 35px;
      left: 50%;
      transform: translateX(-50%);
      width: 65px;
      height: 24px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.7),
        0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    
    .monster-dragon {
      width: 220px; height: 240px;
      position: relative;
      animation: dragonFloat 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes dragonFloat {
      0%, 100% { transform: translateY(0) rotate(-2deg); }
      50% { transform: translateY(-8px) rotate(2deg); }
    }
    .monster-dragon::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #f87171 0%, #ef4444 30%, #dc2626 70%, #991b1b 100%);
      border-radius: 45% 50% 35% 40% / 55% 60% 25% 35%;
      box-shadow: 
        0 30px 60px rgba(239, 68, 68, 0.5),
        inset 0 -50px 80px rgba(153, 27, 27, 0.6),
        inset 0 20px 40px rgba(255, 255, 255, 0.15);
    }
    .dragon-horns {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 60px;
      z-index: 2;
    }
    .dragon-horn-left {
      position: absolute;
      left: 50px;
      top: 0;
      width: 22px;
      height: 52px;
      background: linear-gradient(135deg, #525252, #404040);
      border-radius: 50% 0 50% 50%;
      transform: rotate(-18deg);
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .dragon-horn-left::after {
      content: '';
      position: absolute;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    .dragon-horn-right {
      position: absolute;
      right: 50px;
      top: 0;
      width: 22px;
      height: 52px;
      background: linear-gradient(225deg, #525252, #404040);
      border-radius: 0 50% 50% 50%;
      transform: rotate(18deg);
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .dragon-horn-right::after {
      content: '';
      position: absolute;
      top: 5px;
      right: 5px;
      width: 10px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    .dragon-eyes {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 50px;
      z-index: 3;
    }
    .dragon-eye {
      width: 32px;
      height: 40px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 25px rgba(250, 204, 21, 0.9),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    .dragon-eye::before {
      content: '';
      position: absolute;
      top: 7px;
      left: 7px;
      width: 12px;
      height: 16px;
      background: #000;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .dragon-eye::after {
      content: '';
      position: absolute;
      top: 9px;
      left: 9px;
      width: 5px;
      height: 7px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
    }
    .dragon-snout {
      position: absolute;
      top: 105px;
      left: 50%;
      transform: translateX(-50%);
      width: 42px;
      height: 30px;
      background: linear-gradient(to bottom, #dc2626, #b91c1c);
      border-radius: 50%;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 2;
    }
    .dragon-nostrils {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      gap: 14px;
      z-index: 3;
    }
    .dragon-nostril {
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }
    .dragon-mouth {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 20px;
      background: linear-gradient(to top, #f97316, #ea580c);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.6),
        0 0 15px rgba(249, 115, 22, 0.6);
      animation: fireGlow 1.5s ease-in-out infinite;
      z-index: 2;
    }
    @keyframes fireGlow {
      0%, 100% { box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.5), 0 0 15px rgba(249, 115, 22, 0.6); }
      50% { box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.5), 0 0 25px rgba(249, 115, 22, 0.9); }
    }
    
    .monster-king {
      width: 240px; height: 240px;
      position: relative;
      animation: kingPulse 2.5s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes kingPulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(147, 51, 234, 0.5)); }
      50% { transform: scale(1.03); filter: drop-shadow(0 0 30px rgba(147, 51, 234, 0.8)); }
    }
    .monster-king::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #a855f7 0%, #9333ea 30%, #7c3aed 60%, #6d28d9 100%);
      border-radius: 40% 45% 35% 40% / 45% 50% 40% 45%;
      box-shadow: 
        0 30px 60px rgba(147, 51, 234, 0.6),
        inset 0 -50px 80px rgba(109, 40, 217, 0.7),
        inset 0 30px 50px rgba(255, 255, 255, 0.2);
    }
    .king-crown {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      height: 60px;
      background: transparent;
      z-index: 3;
    }
    .king-crown::before {
      content: 'üëë';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      z-index: 1;
    }
    .king-eyes {
      position: absolute;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 48px;
      z-index: 2;
    }
    .king-eye {
      width: 36px;
      height: 44px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 30px rgba(250, 204, 21, 0.95),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
      animation: kingEyeGlow 2s ease-in-out infinite;
    }
    @keyframes kingEyeGlow {
      0%, 100% { box-shadow: 0 0 25px rgba(250, 204, 21, 0.9), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 35px rgba(250, 204, 21, 1), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
    }
    .king-eye::before {
      content: '';
      position: absolute;
      top: 9px;
      left: 9px;
      width: 14px;
      height: 18px;
      background: #1e293b;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .king-eye::after {
      content: '';
      position: absolute;
      top: 11px;
      left: 11px;
      width: 5px;
      height: 7px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
    }
    .king-mouth {
      position: absolute;
      bottom: 58px;
      left: 50%;
      transform: translateX(-50%);
      width: 95px;
      height: 48px;
      background: linear-gradient(to top, #7c3aed, #6d28d9);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        inset 0 10px 20px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(124, 58, 237, 0.6);
      z-index: 1;
    }
    .king-teeth {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
    }
    .king-tooth {
      width: 8px;
      height: 15px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    .king-aura {
      position: absolute;
      inset: -20px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(147, 51, 234, 0.3) 0%, transparent 70%);
      animation: auraPulse 3s ease-in-out infinite;
      z-index: -1;
    }
    @keyframes auraPulse {
      0%, 100% { transform: scale(1); opacity: 0.3; }
      50% { transform: scale(1.1); opacity: 0.5; }
    }
    .monster-lich {
      width: 200px; height: 220px;
      position: relative;
      animation: lichFloat 3s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes lichFloat {
      0%, 100% { transform: translateY(0) rotate(-1deg); }
      50% { transform: translateY(-5px) rotate(1deg); }
    }
    .monster-lich::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 50%, #1e293b 100%);
      border-radius: 45% 50% 35% 40% / 50% 55% 40% 45%;
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.6),
        inset 0 -40px 60px rgba(0, 0, 0, 0.7),
        inset 0 15px 30px rgba(255, 255, 255, 0.1);
    }
    .lich-skull {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 140px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 40% 40%;
      box-shadow: 
        0 10px 20px rgba(0, 0, 0, 0.5),
        inset 0 -20px 30px rgba(0, 0, 0, 0.3);
    }
    .lich-eyes {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 2;
    }
    .lich-eye {
      width: 20px;
      height: 25px;
      background: #dc2626;
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(220, 38, 38, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.5);
      animation: lichEyeGlow 1.5s ease-in-out infinite;
    }
    @keyframes lichEyeGlow {
      0%, 100% { box-shadow: 0 0 10px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(0, 0, 0, 0.4); }
      50% { box-shadow: 0 0 20px rgba(220, 38, 38, 1), inset 0 0 12px rgba(0, 0, 0, 0.6); }
    }
    .lich-mouth {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 30px;
      border: 3px solid #1e293b;
      border-top: none;
      border-radius: 0 0 50% 50%;
    }
    .lich-robe {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 100px;
      background: linear-gradient(to bottom, #1e293b, #0f172a);
      border-radius: 50% 50% 0 0;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }
    .monster-behemoth {
      width: 260px; height: 280px;
      position: relative;
      animation: behemothRoar 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes behemothRoar {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .monster-behemoth::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #78350f 0%, #92400e 40%, #b45309 100%);
      border-radius: 35% 40% 30% 35% / 50% 55% 35% 40%;
      box-shadow: 
        0 30px 60px rgba(180, 83, 9, 0.5),
        inset 0 -50px 80px rgba(120, 53, 15, 0.6),
        inset 0 20px 40px rgba(255, 255, 255, 0.1);
    }
    .behemoth-head {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 140px;
      background: linear-gradient(135deg, #92400e, #78350f);
      border-radius: 40% 50% 30% 40% / 45% 50% 35% 40%;
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
    }
    .behemoth-eyes {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 60px;
      z-index: 2;
    }
    .behemoth-eye {
      width: 40px;
      height: 35px;
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border-radius: 50%;
      border: 5px solid #78350f;
      box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(220, 38, 38, 0.6);
      position: relative;
    }
    .behemoth-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 10px;
      width: 18px;
      height: 18px;
      background: #b91c1c;
      border-radius: 50%;
    }
    .behemoth-mouth {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 50px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 8px 16px rgba(0, 0, 0, 0.7),
        0 3px 6px rgba(0, 0, 0, 0.4);
    }
    .behemoth-horns {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 80px;
      z-index: 1;
    }
    .behemoth-horn {
      position: absolute;
      width: 25px;
      height: 60px;
      background: linear-gradient(135deg, #525252, #404040);
      border-radius: 50% 0 50% 50%;
      box-shadow: -3px 3px 10px rgba(0, 0, 0, 0.6);
    }
    .behemoth-horn-left {
      left: 40px;
      transform: rotate(-20deg);
    }
    .behemoth-horn-right {
      right: 40px;
      transform: rotate(20deg) scaleX(-1);
    }
    .monster-archdemon {
      width: 240px; height: 260px;
      position: relative;
      animation: archdemonHover 2.5s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes archdemonHover {
      0%, 100% { transform: translateY(0) rotate(-2deg); filter: drop-shadow(0 0 25px rgba(239, 68, 68, 0.6)); }
      50% { transform: translateY(-10px) rotate(2deg); filter: drop-shadow(0 0 35px rgba(239, 68, 68, 0.9)); }
    }
    .monster-archdemon::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #991b1b 0%, #dc2626 30%, #ef4444 70%, #f87171 100%);
      border-radius: 40% 45% 35% 40% / 50% 55% 40% 45%;
      box-shadow: 
        0 35px 70px rgba(239, 68, 68, 0.6),
        inset 0 -60px 100px rgba(153, 27, 27, 0.7),
        inset 0 25px 50px rgba(255, 255, 255, 0.15);
    }
    .archdemon-wings {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 180px;
      z-index: 1;
    }
    .archdemon-wing {
      position: absolute;
      width: 90px;
      height: 160px;
      background: linear-gradient(135deg, #7f1d1d, #991b1b);
      border-radius: 0 50% 50% 0;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }
    .archdemon-wing-left {
      left: 10px;
      transform: rotate(-15deg);
      border-radius: 50% 0 0 50%;
    }
    .archdemon-wing-right {
      right: 10px;
      transform: rotate(15deg) scaleX(-1);
    }
    .archdemon-head {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 140px;
      height: 120px;
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      border-radius: 45% 50% 40% 45% / 50% 55% 35% 40%;
      z-index: 2;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
    }
    .archdemon-eyes {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      z-index: 3;
    }
    .archdemon-eye {
      width: 28px;
      height: 32px;
      background: linear-gradient(135deg, #fef08a, #facc15);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 25px rgba(250, 204, 21, 0.9),
        inset 0 3px 6px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    .archdemon-eye::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      width: 10px;
      height: 12px;
      background: #000;
      border-radius: 50%;
    }
    .archdemon-mouth {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 35px;
      background: linear-gradient(to top, #7f1d1d, #991b1b);
      border-radius: 0 0 50% 50%;
      box-shadow: 
        inset 0 6px 12px rgba(0, 0, 0, 0.7),
        0 0 20px rgba(239, 68, 68, 0.6);
      z-index: 2;
    }
    .monster-chaos {
      width: 280px; height: 280px;
      position: relative;
      animation: chaosPulse 2s ease-in-out infinite;
      max-width: 100%;
    }
    @keyframes chaosPulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 30px rgba(139, 92, 246, 0.6)) drop-shadow(0 0 30px rgba(239, 68, 68, 0.6)); }
      50% { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(139, 92, 246, 0.9)) drop-shadow(0 0 40px rgba(239, 68, 68, 0.9)); }
    }
    .monster-chaos::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%);
      border-radius: 45% 50% 40% 45% / 50% 55% 40% 45%;
      box-shadow: 
        0 40px 80px rgba(124, 58, 237, 0.7),
        inset 0 -60px 100px rgba(109, 40, 217, 0.8),
        inset 0 30px 60px rgba(255, 255, 255, 0.2);
      animation: chaosColorShift 3s ease-in-out infinite;
    }
    @keyframes chaosColorShift {
      0% { background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%); }
      25% { background: linear-gradient(135deg, #ec4899 0%, #ef4444 25%, #7c3aed 50%, #a855f7 75%, #ec4899 100%); }
      50% { background: linear-gradient(135deg, #ef4444 0%, #7c3aed 25%, #a855f7 50%, #ec4899 75%, #ef4444 100%); }
      75% { background: linear-gradient(135deg, #a855f7 0%, #ec4899 25%, #ef4444 50%, #7c3aed 75%, #a855f7 100%); }
      100% { background: linear-gradient(135deg, #7c3aed 0%, #a855f7 25%, #ec4899 50%, #ef4444 75%, #7c3aed 100%); }
    }
    .chaos-crown {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 160px;
      height: 70px;
      background: transparent;
      z-index: 3;
    }
    .chaos-crown::before {
      content: 'üëë';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 50px;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
      z-index: 1;
      animation: crownRotate 4s linear infinite;
    }
    @keyframes crownRotate {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .chaos-eyes {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 55px;
      z-index: 2;
    }
    .chaos-eye {
      width: 40px;
      height: 48px;
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-radius: 50% 50% 45% 45%;
      box-shadow: 
        0 0 35px rgba(250, 204, 21, 1),
        inset 0 3px 6px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.2);
      position: relative;
      animation: chaosEyeGlow 1.5s ease-in-out infinite;
    }
    @keyframes chaosEyeGlow {
      0%, 100% { box-shadow: 0 0 30px rgba(250, 204, 21, 0.9), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 40px rgba(250, 204, 21, 1.2), inset 0 2px 4px rgba(0, 0, 0, 0.2); }
    }
    .chaos-eye::before {
      content: '';
      position: absolute;
      top: 10px;
      left: 12px;
      width: 16px;
      height: 20px;
      background: #1e293b;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    .chaos-eye::after {
      content: '';
      position: absolute;
      top: 12px;
      left: 14px;
      width: 6px;
      height: 8px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
    }
    .chaos-mouth {
      position: absolute;
      bottom: 65px;
      left: 50%;
      transform: translateX(-50%);
      width: 110px;
      height: 55px;
      background: linear-gradient(to top, #7c3aed, #6d28d9);
      border-radius: 50% 50% 0 0;
      box-shadow: 
        inset 0 12px 24px rgba(0, 0, 0, 0.6),
        0 0 25px rgba(124, 58, 237, 0.7);
      z-index: 1;
    }
    .chaos-teeth {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .chaos-tooth {
      width: 10px;
      height: 18px;
      background: #fef3c7;
      border-radius: 0 0 50% 50%;
    }
    .chaos-aura {
      position: absolute;
      inset: -30px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(139, 92, 246, 0.4) 0%, rgba(239, 68, 68, 0.4) 50%, transparent 70%);
      animation: chaosAuraPulse 2s ease-in-out infinite;
      z-index: -1;
    }
    @keyframes chaosAuraPulse {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.2); opacity: 0.6; }
    }
    .hp-bar-container {
      width: 100%;
      padding: 0 1rem;
    }
    @media (max-width: 768px) {
      .hp-bar-container {
        padding: 0 0.5rem;
      }
    }
    .hp-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
      font-weight: bold;
      color: #64748b;
    }
    .hp-bar-bg {
      width: 100%;
      height: 1.5rem;
      background: #e2e8f0;
      border-radius: 9999px;
      overflow: hidden;
    }
    .hp-bar-fill {
      height: 100%;
      transition: width 0.5s ease-out;
      border-radius: 9999px;
      background: linear-gradient(to right, #22c55e, #10b981);
      position: relative;
    }
    .hp-bar-fill.low { background: linear-gradient(to right, #ef4444, #dc2626); }
    .hp-bar-fill.medium { background: linear-gradient(to right, #eab308, #f59e0b); }
    .die {
      width: 80px; height: 80px;
      background: white;
      border: 2px solid #f1f5f9;
      border-radius: 1rem;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 4px;
      padding: 8px;
      cursor: pointer;
      position: relative;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      transition: all 0.2s;
    }
    @media (max-width: 768px) {
      .die {
        width: 60px;
        height: 60px;
        padding: 6px;
        gap: 3px;
      }
    }
    .die:hover { transform: scale(1.05); }
    .die.selected {
      border: 4px solid #60a5fa;
      box-shadow: 0 0 20px rgba(96, 165, 250, 0.5), 0 8px 0 rgba(0, 0, 0, 0.15);
    }
    .die.stunned {
      opacity: 0.6;
      background: #fef3c7;
    }
    .die.rolling {
      animation: rollDice 0.6s ease-in-out;
      pointer-events: none;
    }
    @keyframes rollDice {
      0% {
        transform: rotate(0deg) scale(1) translateY(0);
      }
      25% {
        transform: rotate(90deg) scale(0.9) translateY(-20px);
      }
      50% {
        transform: rotate(180deg) scale(1.1) translateY(-10px);
      }
      75% {
        transform: rotate(270deg) scale(0.9) translateY(-20px);
      }
      100% {
        transform: rotate(360deg) scale(1) translateY(0);
      }
    }
    .die-pip {
      width: 10px;
      height: 10px;
      background: #1e293b;
      border-radius: 50%;
      transition: opacity 0.1s;
      justify-self: center;
      align-self: center;
    }
    .die.rolling .die-pip {
      animation: valueFlash 0.1s infinite;
    }
    @keyframes valueFlash {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.8;
      }
    }
    /* Ï£ºÏÇ¨ÏúÑ Îàà Ìå®ÌÑ¥ÏùÑ ÏúÑÌïú Í∑∏Î¶¨Îìú ÏúÑÏπò */
    .die-pip.pos-1 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-2-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-2-2 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-3-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-3-2 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-3-3 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-4-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-4-2 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-4-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-4-4 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-5-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-5-2 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-5-3 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-5-4 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-5-5 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-6-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-6-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-6-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-6-4 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-6-5 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-6-6 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-7-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-7-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-7-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-7-4 { grid-column: 2; grid-row: 2; }
    .die-pip.pos-7-5 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-7-6 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-7-7 { grid-column: 3; grid-row: 3; }
    .die-pip.pos-8-1 { grid-column: 1; grid-row: 1; }
    .die-pip.pos-8-2 { grid-column: 1; grid-row: 2; }
    .die-pip.pos-8-3 { grid-column: 1; grid-row: 3; }
    .die-pip.pos-8-4 { grid-column: 2; grid-row: 1; }
    .die-pip.pos-8-5 { grid-column: 2; grid-row: 3; }
    .die-pip.pos-8-6 { grid-column: 3; grid-row: 1; }
    .die-pip.pos-8-7 { grid-column: 3; grid-row: 2; }
    .die-pip.pos-8-8 { grid-column: 3; grid-row: 3; }
    .stun-badge {
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        45deg,
        rgba(239, 68, 68, 0.1),
        rgba(239, 68, 68, 0.1) 10px,
        rgba(220, 38, 38, 0.2) 10px,
        rgba(220, 38, 38, 0.2) 20px
      );
      border-radius: 1rem;
      pointer-events: none;
      z-index: 5;
    }
    .die.stunned {
      opacity: 0.6;
      background: #fef3c7;
      border: 2px solid #ef4444;
    }
    .die.special-dice {
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
      border: 2px solid #f1f5f9;
    }
    .die.special-dice::before {
      content: '‚òÖ';
      position: absolute;
      top: 4px;
      left: 4px;
      font-size: 0.875rem;
      color: #9333ea;
      z-index: 10;
      text-shadow: 0 0 4px rgba(147, 51, 234, 0.5);
    }
    .die.special-dice.selected {
      border: 4px solid #60a5fa;
      box-shadow: 0 0 20px rgba(96, 165, 250, 0.5), 0 8px 0 rgba(0, 0, 0, 0.15);
    }
    .die-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      pointer-events: none;
      z-index: 50;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      margin-bottom: 0.5rem;
      line-height: 1.5;
      min-width: 200px;
      text-align: center;
    }
    .die:hover .die-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-5px);
    }
    .die-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(30, 41, 59, 0.95);
    }
    .score-preview {
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(4px);
      border-radius: 1rem;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      margin-bottom: 1rem;
      text-align: center;
    }
    @media (max-width: 768px) {
      .score-preview {
        padding: 0.75rem;
        margin-bottom: 0.75rem;
      }
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-width: 320px;
      margin: 0 auto;
    }
    @media (max-width: 768px) {
      .controls {
        max-width: 100%;
        gap: 0.5rem;
      }
    }
    .btn {
      padding: 1rem 2rem;
      border-radius: 9999px;
      font-size: 1.125rem;
      font-weight: bold;
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }
    @media (max-width: 768px) {
      .btn {
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
      }
    }
    .btn:hover:not(:disabled) { transform: scale(1.05) translateY(-2px); }
    .btn:active:not(:disabled) { transform: scale(0.95); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-roll {
      background: linear-gradient(to right, #6366f1, #8b5cf6);
    }
    .btn-reroll {
      background: linear-gradient(to right, #f59e0b, #f97316);
    }
    .btn-attack {
      background: linear-gradient(to right, #ef4444, #ec4899);
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 1rem;
    }
    .modal {
      background: linear-gradient(to bottom right, #6366f1, #7c3aed);
      border-radius: 1.5rem;
      padding: 2rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 100%;
      text-align: center;
      color: white;
    }
    .reward-option {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }
    .reward-option:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
    }
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .guide-card {
      background: linear-gradient(to bottom right, #6366f1, #7c3aed);
      border-radius: 1.5rem;
      padding: 1.5rem;
      color: white;
      box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.2);
    }
    .guide-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
    }
    .stun-counter {
      text-align: center;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      font-weight: bold;
      color: #f59e0b;
      position: relative;
      display: inline-block;
      cursor: help;
    }
    .stun-counter:hover .stun-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    .stun-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      font-weight: normal;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      pointer-events: none;
      z-index: 50;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      margin-bottom: 0.5rem;
      line-height: 1.5;
      min-width: 280px;
      max-width: 400px;
      text-align: left;
    }
    .stun-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(30, 41, 59, 0.95);
    }
    .rerolls-left {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.125rem;
      font-weight: bold;
      color: #6366f1;
    }
    .owned-rewards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .reward-badge {
      background: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: medium;
    }
    .attack-result {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .attack-result-modal {
      max-width: 400px;
      padding: 1.5rem;
    }
    .attack-result-modal .attack-label {
      font-size: 1.75rem;
      margin-bottom: 0.5rem;
    }
    .counterattack-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      pointer-events: none;
    }
    .counterattack-modal {
      background: linear-gradient(to right, #dc2626, #ea580c);
      border-radius: 1.5rem;
      padding: 2rem;
      color: white;
      text-align: center;
      font-size: 2rem;
      font-weight: black;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback } = React;

    // Game Data
    // Î™¨Ïä§ÌÑ∞ Ïù¥ÎØ∏ÏßÄ ÌååÏùº Í≤ΩÎ°ú (nullÎ°ú ÏÑ§Ï†ïÌïòÎ©¥ ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©)
    const MONSTER_IMAGES = {
      slime: null,   // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      goblin: null,  // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      orc: null,     // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      dragon: null,  // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
      demon: null    // ÏõêÎ≥∏ CSS Î∞©Ïãù ÏÇ¨Ïö©
    };

    const BOSS_TYPES_STAGE_2 = [
      { id: "damage_cap_50", nameKo: "ÌîºÌï¥Îüâ ÏÉÅÌïú Î≥¥Ïä§", descriptionKo: "1Ìöå ÏµúÎåÄ ÌîºÌï¥Í∞Ä Ï≤¥Î†• 50%Î•º ÎÑòÏßÄ Î™ªÌï©ÎãàÎã§." },
      { id: "abyss_curse", nameKo: "Ïã¨Ïó∞Ïùò Ï†ÄÏ£º Î≥¥Ïä§", descriptionKo: "Í∏∞Ï†àÌïú Ï£ºÏÇ¨ÏúÑÍ∞Ä 0,0,0,0,0,0ÏúºÎ°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§." },
      { id: "over21_zero", nameKo: "Í≥ºÏûâ ÎààÍ∏à Î≥¥Ïä§", descriptionKo: "Ï£ºÏÇ¨ÏúÑ ÎààÍ∏àÏù¥ 21 Ï¥àÍ≥ºÏù∏ Í≤ΩÏö∞ ÌîºÌï¥Í∞Ä 0Ïù¥ Îê©ÎãàÎã§." },
      { id: "reroll_max2", nameKo: "Î¶¨Î°§ Ï†úÌïú Î≥¥Ïä§", descriptionKo: "3Í∞ú Ï£ºÏÇ¨ÏúÑ Ïù¥ÏÉÅ ÎèôÏãú Î¶¨Î°§Ïù¥ Î∂àÍ∞ÄÌï©ÎãàÎã§." },
    ];
    const BOSS_TYPES_STAGE_4 = [
      { id: "cursed_dice", nameKo: "Ï†ÄÏ£º Ï£ºÏÇ¨ÏúÑ Î≥¥Ïä§", descriptionKo: "Ï£ºÏÇ¨ÏúÑ 1Í∞úÏóê Ï†ÄÏ£º. Ï†ÄÏ£º Î∞õÏùÄ Ï£ºÏÇ¨ÏúÑÍ∞Ä Ï°±Î≥¥Ïóê Ìè¨Ìï®Îê† Ïãú Îç∞ÎØ∏ÏßÄ 0." },
      { id: "flip_all", nameKo: "Ï†ÑÎ©¥ Îí§ÏßëÍ∏∞ Î≥¥Ïä§", descriptionKo: "Îí§ÏßëÍ∏∞ ÏÇ¨Ïö© Ïãú Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Îí§ÏßëÌûôÎãàÎã§." },
      { id: "reroll_minus1", nameKo: "Î¶¨Î°§ Í∞êÏÜå Î≥¥Ïä§", descriptionKo: "Î¶¨Î°§ ÌöüÏàòÍ∞Ä 1Ìöå Ï∞®Í∞êÎê©ÎãàÎã§." },
    ];
    const BOSS_TYPES_STAGE_6 = [
      { id: "combo_out_stun", nameKo: "ÎØ∏Ìè¨Ìï® Í∏∞Ï†à Î≥¥Ïä§", descriptionKo: "Ï°±Î≥¥Ïóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùÄ Ï£ºÏÇ¨ÏúÑ Ï§ë ÌïòÎÇòÎäî Í∏∞Ï†àÌï©ÎãàÎã§." },
      { id: "pattern_limit", nameKo: "Ìå®ÌÑ¥ Í≥†Ï∞© Î∞©ÏßÄ Î≥¥Ïä§", descriptionKo: "Ï†Ñ ÌÑ¥Í≥º ÎèôÏùºÌïú Ï°±Î≥¥ ÏÇ¨Ïö© Î∂àÍ∞Ä(Í∞ôÏúºÎ©¥ ÌîºÌï¥ 0)." },
    ];
    const BOSS_TYPES_STAGE_8 = [
      { id: "despair_heal", nameKo: "Ï†àÎßùÏùò ÌöåÎ≥µ Î≥¥Ïä§", descriptionKo: "Î¶¨Î°§ Ïãú Î≥¥Ïä§ Ï≤¥Î†• 10% ÌöåÎ≥µ." },
    ];
    const BOSS_TYPES_ALL = [...BOSS_TYPES_STAGE_2, ...BOSS_TYPES_STAGE_4, ...BOSS_TYPES_STAGE_6, ...BOSS_TYPES_STAGE_8];

    const STAGES = [
      { id: 1, name: "Slime", nameKo: "Ïä¨ÎùºÏûÑ", hp: 100, iconName: "Droplet", imageUrl: MONSTER_IMAGES.slime, isBoss: false },
      { id: 2, name: "Goblin", nameKo: "Í≥†Î∏îÎ¶∞", hp: 200, iconName: "Skull", imageUrl: MONSTER_IMAGES.goblin, isBoss: true },
      { id: 3, name: "Orc", nameKo: "Ïò§ÌÅ¨", hp: 300, iconName: "Axe", imageUrl: MONSTER_IMAGES.orc, isBoss: false },
      { id: 4, name: "Dragon", nameKo: "ÎìúÎûòÍ≥§", hp: 400, iconName: "Flame", imageUrl: MONSTER_IMAGES.dragon, isBoss: true },
      { id: 5, name: "Demon King", nameKo: "ÎßàÏôï", hp: 500, iconName: "Crown", imageUrl: MONSTER_IMAGES.demon, isBoss: false },
      { id: 6, name: "Lich", nameKo: "Î¶¨Ïπò", hp: 600, iconName: "Skull", imageUrl: null, isBoss: true },
      { id: 7, name: "Behemoth", nameKo: "Î≤†ÌûàÎ™®Ïä§", hp: 700, iconName: "Axe", imageUrl: null, isBoss: false },
      { id: 8, name: "Chaos Lord", nameKo: "Ïπ¥Ïò§Ïä§ Î°úÎìú", hp: 800, iconName: "Crown", imageUrl: null, isBoss: true },
    ];

    const REWARDS = [
      { id: "odd_power", name: "Odd Power", nameKo: "ÌôÄÏàòÏùò Ìûò", descriptionKo: "Î™®Îì† Ï£ºÏÇ¨ÏúÑ ÌôÄÏàòÏùºÏãú x2", iconName: "Target" },
      { id: "even_power", name: "Even Power", nameKo: "ÏßùÏàòÏùò Ìûò", descriptionKo: "Î™®Îì† Ï£ºÏÇ¨ÏúÑ ÏßùÏàòÏùºÏãú x2", iconName: "Target" },
      { id: "giants_strike", name: "Giant's Strike", nameKo: "Í±∞Ïù∏Ïùò ÏùºÍ≤©", descriptionKo: "Ï£ºÏÇ¨ÏúÑ Ìï©Í≥Ñ 24 Ïù¥ÏÉÅÏùºÏãú x2", iconName: "Dumbbell" },
      { id: "raging_power", name: "Raging Power", nameKo: "Ìè≠Ï£ºÌïòÎäî Ìûò", descriptionKo: "Ï£ºÏÇ¨ÏúÑ+1, Î¶¨Î°§Ïãú Î™®Îì† Ï£ºÏÇ¨ÏúÑ Ïû¨Íµ¥Î¶º", iconName: "Flame" },
      { id: "final_strike", name: "Final Strike", nameKo: "ÎßàÏßÄÎßâ ÏùºÍ≤©", descriptionKo: "Î™¨Ïä§ÌÑ∞ Ï≤¥Î†• 50% Ïù¥ÌïòÏùºÏãú x2", iconName: "Target" },
      { id: "skilled_hands", name: "Skilled Hands", nameKo: "ÏàôÎ†®Îêú ÏÜêÍ∏∏", descriptionKo: "Î¶¨Î°§ +1", iconName: "Hand" },
      { id: "cursed_power", name: "Cursed Power", nameKo: "Ï†ÄÏ£ºÎ∞õÏùÄ Ìûò", descriptionKo: "Ï°±Î≥¥Ïóê Ï£ºÏÇ¨ÏúÑ 1 Ìè¨Ìï®Ïãú 0, x2", iconName: "Skull" },
      { id: "multi_flip", name: "Multi Flip", nameKo: "Îã§Ï§ë Îí§ÏßëÍ∏∞", descriptionKo: "Îí§ÏßëÍ∏∞ ÏÇ¨Ïö©Ïãú 1ÌöåÏóê Ïó¨Îü¨ Ï£ºÏÇ¨ÏúÑ ÏÇ¨Ïö© Í∞ÄÎä•", iconName: "Target" },
      { id: "flip_double", name: "Flip Double", nameKo: "Îí§ÏßëÍ∏∞ Î∞∞Ïú®", descriptionKo: "Îí§ÏßëÍ∏∞ ÏÇ¨Ïö©Ïãú x2", iconName: "Target" },
      { id: "flip_all_double", name: "Flip All Double", nameKo: "Ï†ÑÎ©¥ Îí§ÏßëÍ∏∞", descriptionKo: "Îí§ÏßëÍ∏∞ ÏÇ¨Ïö©Ïãú Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Îí§ÏßëÌûò, x2", iconName: "Target" },
      { id: "blood_contract", name: "Blood Contract", nameKo: "ÌîºÏùò Í≥ÑÏïΩ", descriptionKo: "Ï£ºÏÇ¨ÏúÑ 1Í∞ú Î¨¥ÏûëÏúÑÎ°ú ÌååÍ¥¥, x3", iconName: "Target" },
      { id: "random_combo_boost", name: "Random Combo Boost", nameKo: "Î¨¥ÏûëÏúÑ Ï°±Î≥¥ Í∞ïÌôî", descriptionKo: "Ï†ÑÌà¨ ÌõÑ Î¨¥ÏûëÏúÑ Ï°±Î≥¥+1", iconName: "Target" },
      { id: "random_die_enhance", name: "Random Die Enhance", nameKo: "Í≥µÍ≤© ÌõÑ Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî", descriptionKo: "Í≥µÍ≤© ÌõÑ Ï°±Î≥¥Ïóê Ìè¨Ìï®Îêú Î¨¥ÏûëÏúÑ Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî+1", iconName: "Target" },
      { id: "dice_flip_gain", name: "Dice Flip Gain", nameKo: "Îí§ÏßëÍ∏∞ ÌöçÎìù", descriptionKo: "Ï†ÑÌà¨ ÌõÑ Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ ÌöçÎìù+1", iconName: "Target" },
      { id: "dice_shield", name: "Dice Shield", nameKo: "Ï£ºÏÇ¨ÏúÑ Î≥¥Ìò∏Îßâ", descriptionKo: "1Í∞ú Ï£ºÏÇ¨ÏúÑ Î≥¥Ìò∏Îßâ ÏÉùÏÑ±, Ìï¥Îãπ Ï£ºÏÇ¨ÏúÑ Í∏∞Ï†àÏãú Í∏∞Ï†à 1Ìöå Î¨¥Ìö®, Ï†ÑÌà¨ ÌõÑ Î≥¥Ìò∏Îßâ Î¶¨ÌïÑ", iconName: "Target" },
      { id: "small_straight_3", name: "Small Straight 3", nameKo: "Ï∂ïÏÜå Ïä§Ìä∏Î†àÏù¥Ìä∏", descriptionKo: "Ïó∞ÏÜçÎêú Ïà´Ïûê 3Í∞úÎ°úÎèÑ Ïä§Î™∞ Ïä§Ìä∏Î†àÏù¥Ìä∏ Í∞ÄÎä•", iconName: "Target" },
      { id: "triple_2", name: "Triple 2", nameKo: "Ïù¥Ï§ë Ìä∏Î¶¨Ìîå", descriptionKo: "ÎèôÏùº Ïà´Ïûê 2Í∞úÎ°úÎèÑ Ìä∏Î¶¨Ìîå Í∞ÄÎä•", iconName: "Target" },
      { id: "mega_enhance", name: "Mega Enhance", nameKo: "Î©îÍ∞Ä Í∞ïÌôî", descriptionKo: "Î¨¥ÏûëÏúÑ Ï£ºÏÇ¨ÏúÑ Í∞ïÌôî+10", iconName: "Target" },
      { id: "reroll_burn", name: "Reroll Burn", nameKo: "Î¶¨Î°§ ÌôîÏÉÅ", descriptionKo: "Î¶¨Î°§Ïãú Î¶¨Î°§Ìïú Ï£ºÏÇ¨ÏúÑ ÎààÍ∏àÎßåÌÅº ÌîºÌï¥(Í∞ïÌôî Î∞òÏòÅ)", iconName: "Target" },
      { id: "sum13_x5", name: "Sum 13 x5", nameKo: "13Ïùò Î∞∞Ïú®", descriptionKo: "Ï£ºÏÇ¨ÏúÑ Ìï©Í≥ÑÍ∞Ä 13ÏùºÏãú x5", iconName: "Target" },
      { id: "dice_6_1", name: "6¬∑1 Dice", nameKo: "6¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,1][6,1][2,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_0", name: "6¬∑0 Dice", nameKo: "6¬∑0 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,0][6,0][6,0] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_3", name: "5¬∑3 Dice", nameKo: "5¬∑3 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,3][5,3][5,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_2", name: "5¬∑2 Dice", nameKo: "5¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,2][5,2][5,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_1", name: "5¬∑1 Dice", nameKo: "5¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,1][5,1][5,1] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_4_3", name: "4¬∑3 Dice", nameKo: "4¬∑3 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [4,3][4,3][4,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_4_2", name: "4¬∑2 Dice", nameKo: "4¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [4,2][4,2][4,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_4_2", name: "6¬∑4¬∑2 Dice", nameKo: "6¬∑4¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,4][6,4][2,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_4_3", name: "5¬∑4¬∑3 Dice", nameKo: "5¬∑4¬∑3 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,4][5,4][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_5_1", name: "6¬∑5¬∑1 Dice", nameKo: "6¬∑5¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,5][6,5][1,1] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_4_1", name: "6¬∑4¬∑1 Dice", nameKo: "6¬∑4¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,4][6,4][1,1] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_4_2", name: "5¬∑4¬∑2 Dice", nameKo: "5¬∑4¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,4][5,4][2,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_4_0", name: "6¬∑4¬∑0 Dice", nameKo: "6¬∑4¬∑0 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,4][6,4][0,0] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_4_1", name: "5¬∑4¬∑1 Dice", nameKo: "5¬∑4¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,1][5,1][4,4] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_3_1", name: "6¬∑3¬∑1 Dice", nameKo: "6¬∑3¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,1][6,1][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_3_2", name: "5¬∑3¬∑2 Dice", nameKo: "5¬∑3¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,2][5,2][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_4_0", name: "5¬∑4¬∑0 Dice", nameKo: "5¬∑4¬∑0 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,4][5,4][0,0] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_3_0", name: "6¬∑3¬∑0 Dice", nameKo: "6¬∑3¬∑0 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,0][6,0][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_5_3_1", name: "5¬∑3¬∑1 Dice", nameKo: "5¬∑3¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [5,1][5,1][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_4_3_2", name: "4¬∑3¬∑2 Dice", nameKo: "4¬∑3¬∑2 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [4,2][4,2][3,3] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
      { id: "dice_6_2_1", name: "6¬∑2¬∑1 Dice", nameKo: "6¬∑2¬∑1 Îã§Ïù¥Ïä§", descriptionKo: "1Í∞úÏùò ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑÎ•º [6,1][6,1][2,2] Î©¥ Íµ¨ÏÑ±ÏúºÎ°ú ÍµêÏ≤¥Ìï©ÎãàÎã§", iconName: "Target" },
    ];

    const COMBINATIONS = {
      yahtzee: { multiplier: 20, label: "Yahtzee", labelKo: "ÏïºÏ∞å (5Í∞ú ÎèôÏùº)" },
      largeStraight: { multiplier: 10, label: "Large Straight", labelKo: "ÎùºÏßÄ Ïä§Ìä∏Î†àÏù¥Ìä∏ (5Í∞ú Ïó∞ÏÜç)" },
      fourOfAKind: { multiplier: 8, label: "4 of a Kind", labelKo: "Ìè¨Ïπ¥Îìú (4Í∞ú ÎèôÏùº)" },
      fullHouse: { multiplier: 6, label: "Full House", labelKo: "ÌíÄ ÌïòÏö∞Ïä§ (3+2)" },
      smallStraight: { multiplier: 4, label: "Small Straight", labelKo: "Ïä§Î™∞ Ïä§Ìä∏Î†àÏù¥Ìä∏ (4Í∞ú Ïó∞ÏÜç)" },
      twoPair: { multiplier: 3, label: "Two Pair", labelKo: "Ìà¨ÌéòÏñ¥ (2Ïåç)" },
      threeOfAKind: { multiplier: 2, label: "3 of a Kind", labelKo: "Ìä∏Î¶¨Ìîå (3Í∞ú ÎèôÏùº)" },
      chance: { multiplier: 1, label: "Chance", labelKo: "Ï∞¨Ïä§" },
    };

    const ENHANCEMENT_GROUPS = [
      { id: 'four_yahtzee', labelKo: 'Ìè¨Ïπ¥Îìú/ÏïºÏ∞å Í∞ïÌôî', comboKeys: ['fourOfAKind', 'yahtzee'] },
      { id: 'straight', labelKo: 'Ïä§Ìä∏Î†àÏù¥Ìä∏ Í∞ïÌôî (ÎùºÏßÄ, Ïä§Î™∞)', comboKeys: ['largeStraight', 'smallStraight'] },
      { id: 'full_house', labelKo: 'ÌíÄÌïòÏö∞Ïä§ Í∞ïÌôî', comboKeys: ['fullHouse'] },
      { id: 'triple', labelKo: 'Ìä∏Î¶¨Ìîå Í∞ïÌôî', comboKeys: ['threeOfAKind'] },
      { id: 'two_pair', labelKo: 'Ìà¨ÌéòÏñ¥ Í∞ïÌôî', comboKeys: ['twoPair'] },
      { id: 'chance', labelKo: 'Ï∞¨Ïä§ Í∞ïÌôî', comboKeys: ['chance'] },
    ];

    const BATTLE_LOG_URL = 'https://script.google.com/macros/s/AKfycbxbvi_bo_IH8-XDGc_pGojpUFtNZfSvpYZFvwwWFy5_bhmQKVFAV81fGQvghi2P6ujr/exec';
    function sendBattleLog(stage, bossType, result, enhancementChoice, rewardChoice) {
      if (!BATTLE_LOG_URL) return;
      try {
        fetch(BATTLE_LOG_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ stage, bossType, result, enhancementChoice, rewardChoice, timestamp: new Date().toISOString() })
        }).catch(function() {});
      } catch (e) {}
    }

    // 6Î©¥ Ï£ºÏÇ¨ÏúÑ faces[6]: Ïù∏Îç±Ïä§ Ïåç (0,5), (1,4), (2,3)Ïù¥ ÎßàÏ£ºÎ¥Ñ. Îí§ÏßëÍ∏∞ Ïãú 5-i Ïù∏Îç±Ïä§ Í∞í ÏÇ¨Ïö©.
    const DICE_FACES = {
      normal: [1,2,3,4,5,6],
      all_two: [3,3,3,3,3,3],
      extreme: [0,0,0,6,6,6],
      even: [2,2,4,4,6,6],
      odd: [1,3,3,3,5,5],
      middle: [3,3,3,4,4,4],
      dice_6_1: [6,6,2,2,1,1],
      dice_6_0: [6,6,6,0,0,0],
      dice_5_3: [5,5,5,3,3,3],
      dice_5_2: [5,5,5,2,2,2],
      dice_5_1: [5,5,5,1,1,1],
      dice_4_3: [4,4,4,3,3,3],
      dice_4_2: [4,4,4,2,2,2],
      dice_6_4_2: [6,6,2,2,4,4],
      dice_5_4_3: [5,5,3,3,4,4],
      dice_6_5_1: [6,6,1,1,5,5],
      dice_6_4_1: [6,6,1,1,4,4],
      dice_5_4_2: [5,5,2,2,4,4],
      dice_6_4_0: [6,6,0,0,4,4],
      dice_5_4_1: [5,5,4,4,1,1],
      dice_6_3_1: [6,6,3,3,1,1],
      dice_5_3_2: [5,5,3,3,2,2],
      dice_5_4_0: [5,5,0,0,4,4],
      dice_6_3_0: [6,6,3,3,0,0],
      dice_5_3_1: [5,5,3,3,1,1],
      dice_4_3_2: [4,4,3,3,2,2],
      dice_6_2_1: [6,6,2,2,1,1],
      abyss_cursed: [0,0,0,0,0,0],
    };
    function getDiceFaces(type) { return DICE_FACES[type] || null; }

    function rollDieWithIndex(type, isStunned = false) {
      if (isStunned && type !== 'abyss_cursed') {
        const faces = [0,0,0,1,1,1];
        const i = Math.floor(Math.random() * 6);
        return { value: faces[i], faceIndex: i };
      }
      const faces = getDiceFaces(type);
      if (faces) {
        const i = Math.floor(Math.random() * 6);
        return { value: faces[i], faceIndex: i };
      }
      if (type === "d8") return { value: Math.floor(Math.random() * 8) + 1, faceIndex: 0 };
      if (type === "d6_2_7") return { value: Math.floor(Math.random() * 6) + 2, faceIndex: 0 };
      const v = Math.floor(Math.random() * 6) + 1;
      return { value: v, faceIndex: v - 1 };
    }

    // Scoring Logic
    function getCounts(dice) {
      const counts = new Map();
      for (const die of dice) {
        counts.set(die, (counts.get(die) || 0) + 1);
      }
      return counts;
    }

    function isYahtzee(counts, diceCount) {
      return diceCount >= 5 && Array.from(counts.values()).some(count => count >= 5);
    }

    function isLargeStraight(dice) {
      if (dice.length < 5) return false;
      const sorted = [...dice].sort((a, b) => a - b);
      const unique = Array.from(new Set(sorted));
      if (unique.length < 5) return false;
      for (let i = 0; i <= unique.length - 5; i++) {
        let consecutive = true;
        for (let j = 0; j < 4; j++) {
          if (unique[i + j + 1] - unique[i + j] !== 1) {
            consecutive = false;
            break;
          }
        }
        if (consecutive) return true;
      }
      return false;
    }

    function isSmallStraight(dice, ownedRewards = []) {
      if (ownedRewards.includes('small_straight_3') && hasThreeConsecutive(dice)) return true;
      const unique = Array.from(new Set(dice)).sort((a, b) => a - b);
      const sequences = [[0,1,2,3], [1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7], [5,6,7,8]];
      return sequences.some(seq => seq.every(num => unique.includes(num)));
    }

    function hasThreeConsecutive(dice) {
      const unique = Array.from(new Set(dice)).sort((a, b) => a - b);
      if (unique.length < 3) return false;
      for (let i = 0; i <= unique.length - 3; i++) {
        if (unique[i + 1] - unique[i] === 1 && unique[i + 2] - unique[i + 1] === 1) {
          return true;
        }
      }
      return false;
    }

    function detectCombination(dice, options = {}) {
      const { ownedRewards = [] } = options;
      const counts = getCounts(dice);
      const diceCount = dice.length;
      if (isYahtzee(counts, diceCount)) return "yahtzee";
      if (isLargeStraight(dice)) return "largeStraight";
      if (Array.from(counts.values()).some(c => c >= 4)) return "fourOfAKind";
      const sorted = Array.from(counts.values()).sort((a, b) => b - a);
      if (diceCount >= 5 && sorted.length === 2 && sorted[0] === 3 && sorted[1] === 2) return "fullHouse";
      if (isSmallStraight(dice, ownedRewards)) return "smallStraight";
      const pairs = Array.from(counts.values()).filter(c => c >= 2);
      if (pairs.length >= 2) return "twoPair";
      if (Array.from(counts.values()).some(c => c >= 3 || (ownedRewards.includes('triple_2') && c >= 2))) return "threeOfAKind";
      return "chance";
    }

    function getComboIndices(dice, combination, options = {}) {
      const { ownedRewards = [] } = options;
      const n = dice.length;
      const counts = getCounts(dice);
      const idxOf = (v) => Array.from({ length: n }, (_, i) => i).filter(i => dice[i] === v);
      if (["yahtzee", "largeStraight", "fullHouse", "smallStraight", "chance"].includes(combination))
        return Array.from({ length: n }, (_, i) => i);
      if (combination === "fourOfAKind") {
        const v = Array.from(counts.entries()).find(([_, c]) => c >= 4)?.[0];
        if (v == null) return [];
        return idxOf(v).slice(0, 4);
      }
      if (combination === "twoPair") {
        const pairVals = Array.from(counts.entries()).filter(([_, c]) => c >= 2).map(([v]) => v).sort((a, b) => b - a).slice(0, 2);
        const out = [];
        for (const v of pairVals) {
          const ii = idxOf(v);
          for (let i = 0; i < Math.min(2, ii.length); i++) out.push(ii[i]);
        }
        return out;
      }
      if (combination === "threeOfAKind") {
        const need = ownedRewards.includes("triple_2") ? 2 : 3;
        const v = Array.from(counts.entries()).find(([_, c]) => c >= need)?.[0];
        if (v == null) return [];
        return idxOf(v).slice(0, need);
      }
      return [];
    }

    function calculateScore(dice, options = {}) {
      const { ownedRewards = [], monsterHp = 0, maxMonsterHp = 0, diceEnhancements = [], combinationBoosts = {}, usedFlipThisRound = false } = options;
      let sum = dice.reduce((a, b) => a + b, 0);
      const combination = detectCombination(dice, options);
      let enhancementBonus = 0;
      if (diceEnhancements.length > 0) {
        const counts = getCounts(dice);
        const sortedDice = [...dice].map((v, i) => ({ value: v, idx: i })).sort((a, b) => a.value - b.value);
        if (combination === "yahtzee") {
          sortedDice.forEach(({ idx }) => { if (diceEnhancements[idx] > 0) enhancementBonus += diceEnhancements[idx]; });
        } else if (combination === "fourOfAKind") {
          const fourValue = Array.from(counts.entries()).find(([_, c]) => c >= 4)?.[0];
          let used = 0;
          sortedDice.forEach(({ value, idx }) => { if (value === fourValue && used < 4 && diceEnhancements[idx] > 0) { enhancementBonus += diceEnhancements[idx]; used++; } });
        } else if (combination === "fullHouse") {
          const threeV = Array.from(counts.entries()).find(([_, c]) => c >= 3)?.[0];
          const twoV = Array.from(counts.entries()).find(([_, c]) => c >= 2 && c < 3)?.[0];
          sortedDice.forEach(({ value, idx }) => { if ((value === threeV || value === twoV) && diceEnhancements[idx] > 0) enhancementBonus += diceEnhancements[idx]; });
        } else if (combination === "threeOfAKind") {
          const threeV = Array.from(counts.entries()).find(([_, c]) => c >= 3)?.[0];
          let used = 0;
          sortedDice.forEach(({ value, idx }) => { if (value === threeV && used < 3 && diceEnhancements[idx] > 0) { enhancementBonus += diceEnhancements[idx]; used++; } });
        } else if (combination === "twoPair") {
          const pairVals = Array.from(counts.entries()).filter(([_, c]) => c >= 2).map(([v]) => v);
          const used = new Map(); pairVals.forEach(v => used.set(v, 0));
          sortedDice.forEach(({ value, idx }) => { if (pairVals.includes(value) && used.get(value) < 2 && diceEnhancements[idx] > 0) { enhancementBonus += diceEnhancements[idx]; used.set(value, used.get(value) + 1); } });
        } else {
          sortedDice.forEach(({ idx }) => { if (diceEnhancements[idx] > 0) enhancementBonus += diceEnhancements[idx]; });
        }
      }
      sum += enhancementBonus;
      let { multiplier, label, labelKo } = COMBINATIONS[combination];
      multiplier = multiplier + (combinationBoosts[combination] || 0);
      const rewardMultipliers = [];
      let isCursed = false;
      
      if (ownedRewards.includes("cursed_power")) {
        if (dice.some(d => d === 1)) {
          isCursed = true;
        } else {
          rewardMultipliers.push({ rewardId: "cursed_power", multiplier: 2 });
        }
      }
      
      if (!isCursed) {
        // Í±∞Ïù∏Ïùò ÏùºÍ≤©: ÌåêÏ†ïÏóê Í∞ïÌôî Î≥¥ÎÑàÏä§ Ï†úÏô∏ (Ï£ºÏÇ¨ÏúÑ Îàà Ìï©Îßå 24 Ïù¥ÏÉÅ)
        if (ownedRewards.includes("giants_strike") && (sum - enhancementBonus) >= 24) {
          rewardMultipliers.push({ rewardId: "giants_strike", multiplier: 2 });
        }
        if (ownedRewards.includes("final_strike") && maxMonsterHp > 0 && monsterHp <= maxMonsterHp * 0.5) {
          rewardMultipliers.push({ rewardId: "final_strike", multiplier: 2 });
        }
        if (ownedRewards.includes("blood_contract")) {
          rewardMultipliers.push({ rewardId: "blood_contract", multiplier: 3 });
        }
        // ÌôÄÏàòÏùò Ìûò: Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä ÌôÄÏàòÏù∏ÏßÄ Ï≤¥ÌÅ¨
        if (ownedRewards.includes("odd_power") && dice.every(d => d % 2 === 1 && d > 0)) {
          rewardMultipliers.push({ rewardId: "odd_power", multiplier: 2 });
        }
        // ÏßùÏàòÏùò Ìûò: Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä ÏßùÏàòÏù∏ÏßÄ Ï≤¥ÌÅ¨ (0ÏùÄ Ï†úÏô∏)
        if (ownedRewards.includes("even_power") && dice.every(d => d % 2 === 0 && d > 0)) {
          rewardMultipliers.push({ rewardId: "even_power", multiplier: 2 });
        }
        // 13Ïùò Î∞∞Ïú®: Ï£ºÏÇ¨ÏúÑ Ìï©Í≥ÑÍ∞Ä 13ÏùºÏãú x5 (Í∞ïÌôî Ï†úÏô∏)
        if (ownedRewards.includes("sum13_x5") && (sum - enhancementBonus) === 13) {
          rewardMultipliers.push({ rewardId: "sum13_x5", multiplier: 5 });
        }
        // Îí§ÏßëÍ∏∞ Î∞∞Ïú®: flip_double / flip_all_double Î≥¥Ïú† Ïãú Ïù¥Î≤à ÌÑ¥Ïóê Îí§ÏßëÍ∏∞ ÏÇ¨Ïö©ÌïòÎ©¥ x2
        if ((ownedRewards.includes("flip_double") || ownedRewards.includes("flip_all_double")) && usedFlipThisRound) {
          rewardMultipliers.push({ rewardId: "flip_double", multiplier: 2 });
        }
      }
      
      const finalMultiplier = rewardMultipliers.reduce((acc, r) => acc * r.multiplier, 1);
      const baseTotal = sum * multiplier;
      const total = isCursed ? 0 : baseTotal * finalMultiplier;
      
      return { combination, multiplier, sum, total, label, labelKo, rewardMultipliers, finalMultiplier, isCursed, enhancementBonus: enhancementBonus || 0 };
    }

    // Game Logic
    function getInitialPlayerState() {
      return {
        ownedRewards: [],
        encounteredRewards: [],
        baseRerolls: 2,
        diceTypes: ["normal", "normal", "normal", "normal", "normal"],
        holdDisabled: false,
        currentStage: 1,
        diceFlipStacks: 1,
        diceEnhancements: [0, 0, 0, 0, 0],
        combinationBoosts: {},
        shieldIndex: null,
        shieldUsed: false,
        usedFlipThisRound: false,
      };
    }

    function rollDieByType(type, isStunned = false) {
      if (isStunned) {
        const stunnedValues = [0, 0, 0, 1, 1, 1];
        return stunnedValues[Math.floor(Math.random() * 6)];
      }
      switch (type) {
        case "d8": return Math.floor(Math.random() * 8) + 1;
        case "d6_2_7": return Math.floor(Math.random() * 6) + 2;
        case "all_two": return 3; // Ìï≠ÏÉÅ 3
        case "extreme": {
          const extremeValues = [0, 0, 0, 6, 6, 6];
          return extremeValues[Math.floor(Math.random() * 6)];
        }
        case "even": {
          const evenValues = [2, 2, 4, 4, 6, 6];
          return evenValues[Math.floor(Math.random() * 6)];
        }
        case "odd": {
          const oddValues = [1, 3, 3, 3, 5, 5];
          return oddValues[Math.floor(Math.random() * 6)];
        }
        case "middle": {
          const middleValues = [3, 3, 3, 4, 4, 4];
          return middleValues[Math.floor(Math.random() * 6)];
        }
        default: return Math.floor(Math.random() * 6) + 1;
      }
    }

    function getRandomRewards(count, excludeIds = [], currentStage = 1) {
      let available = REWARDS.filter(r => !excludeIds.includes(r.id));
      // 1,3,5,7 ÎùºÏö¥Îìú: Ï£ºÏÇ¨ÏúÑ Î≥ÄÌòï(dice_*)Îßå / 2,4,6 ÎùºÏö¥Îìú: Ìå®ÏãúÎ∏å Î≥¥ÏÉÅÎßå
      const isDiceVariantRound = [1, 3, 5, 7].includes(currentStage);
      const isPassiveRound = [2, 4, 6].includes(currentStage);
      if (isDiceVariantRound) available = available.filter(r => r.id.startsWith('dice_'));
      else if (isPassiveRound) available = available.filter(r => !r.id.startsWith('dice_'));
      const shuffled = [...available].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    }

    function applyReward(state, rewardId) {
      const newState = { ...state, ownedRewards: [...state.ownedRewards, rewardId] };
      switch (rewardId) {
        case "skilled_hands":
          newState.baseRerolls += 1;
          break;
        case "raging_power":
          newState.diceTypes = [...newState.diceTypes, "normal"];
          newState.holdDisabled = true;
          break;
        case "blood_contract": {
          if (newState.diceTypes.length > 1) {
            const idx = Math.floor(Math.random() * newState.diceTypes.length);
            newState.diceTypes = newState.diceTypes.filter((_, i) => i !== idx);
            const e = [...(newState.diceEnhancements || [])];
            e.splice(idx, 1);
            while (e.length < newState.diceTypes.length) e.push(0);
            newState.diceEnhancements = e.slice(0, newState.diceTypes.length);
            if (newState.shieldIndex != null) {
              if (idx === newState.shieldIndex) newState.shieldIndex = null;
              else if (idx < newState.shieldIndex) newState.shieldIndex = newState.shieldIndex - 1;
            }
          }
          break;
        }
        case "dice_shield": {
          newState.shieldIndex = newState.diceTypes.length > 0 ? Math.floor(Math.random() * newState.diceTypes.length) : null;
          newState.shieldUsed = false;
          break;
        }
        case "mega_enhance": {
          let e = [...(newState.diceEnhancements || [])];
          while (e.length < newState.diceTypes.length) e.push(0);
          const i = Math.floor(Math.random() * e.length);
          e[i] = (e[i] || 0) + 10;
          newState.diceEnhancements = e;
          break;
        }
        case "dice_6_1": case "dice_6_0": case "dice_5_3": case "dice_5_2": case "dice_5_1": case "dice_4_3": case "dice_4_2":
        case "dice_6_4_2": case "dice_5_4_3": case "dice_6_5_1": case "dice_6_4_1": case "dice_5_4_2": case "dice_6_4_0": case "dice_5_4_1":
        case "dice_6_3_1": case "dice_5_3_2": case "dice_5_4_0": case "dice_6_3_0": case "dice_5_3_1": case "dice_4_3_2": case "dice_6_2_1": {
          const newType = rewardId;
          newState.diceTypes = [...newState.diceTypes];
          let changed = 0;
          for (let i = 0; i < newState.diceTypes.length && changed < 1; i++) {
            if (newState.diceTypes[i] === "normal") {
              newState.diceTypes[i] = newType;
              changed++;
            }
          }
          break;
        }
      }
      return newState;
    }

    function triggerConfetti(scoreResult) {
      if (scoreResult.multiplier >= 20) {
        confetti({ particleCount: 200, spread: 100, origin: { y: 0.5 }, colors: ["#FFD700", "#FFA500", "#FF6347"] });
      } else if (scoreResult.multiplier >= 10) {
        confetti({ particleCount: 150, spread: 80, origin: { y: 0.6 }, colors: ["#9333ea", "#6366f1", "#ec4899"] });
      } else if (scoreResult.multiplier >= 6) {
        confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ["#3b82f6", "#06b6d4"] });
      } else if (scoreResult.multiplier >= 4) {
        confetti({ particleCount: 50, spread: 50, origin: { y: 0.6 }, colors: ["#22c55e", "#10b981"] });
      }
    }

    function triggerVictoryConfetti() {
      const duration = 3000;
      const end = Date.now() + duration;
      const frame = () => {
        confetti({ particleCount: 7, angle: 60, spread: 55, origin: { x: 0 }, colors: ["#FFD700", "#FFA500", "#FF6347", "#9333ea", "#3b82f6"] });
        confetti({ particleCount: 7, angle: 120, spread: 55, origin: { x: 1 }, colors: ["#FFD700", "#FFA500", "#FF6347", "#9333ea", "#3b82f6"] });
        if (Date.now() < end) requestAnimationFrame(frame);
      };
      frame();
    }

    // Ï£ºÏÇ¨ÏúÑ Îàà Ìå®ÌÑ¥ ÏÉùÏÑ± Ìï®Ïàò
    function renderDicePips(value) {
      if (value === 0) {
        return <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontWeight: 'bold' }}>0</div>; // 0 Í∞í ÌëúÏãú
      }
      
      const pips = [];
      
      if (value === 1) {
        pips.push(<div key="1" className="die-pip pos-1" />);
      } else if (value === 2) {
        pips.push(<div key="1" className="die-pip pos-2-1" />);
        pips.push(<div key="2" className="die-pip pos-2-2" />);
      } else if (value === 3) {
        pips.push(<div key="1" className="die-pip pos-3-1" />);
        pips.push(<div key="2" className="die-pip pos-3-2" />);
        pips.push(<div key="3" className="die-pip pos-3-3" />);
      } else if (value === 4) {
        pips.push(<div key="1" className="die-pip pos-4-1" />);
        pips.push(<div key="2" className="die-pip pos-4-2" />);
        pips.push(<div key="3" className="die-pip pos-4-3" />);
        pips.push(<div key="4" className="die-pip pos-4-4" />);
      } else if (value === 5) {
        pips.push(<div key="1" className="die-pip pos-5-1" />);
        pips.push(<div key="2" className="die-pip pos-5-2" />);
        pips.push(<div key="3" className="die-pip pos-5-3" />);
        pips.push(<div key="4" className="die-pip pos-5-4" />);
        pips.push(<div key="5" className="die-pip pos-5-5" />);
      } else if (value === 6) {
        pips.push(<div key="1" className="die-pip pos-6-1" />);
        pips.push(<div key="2" className="die-pip pos-6-2" />);
        pips.push(<div key="3" className="die-pip pos-6-3" />);
        pips.push(<div key="4" className="die-pip pos-6-4" />);
        pips.push(<div key="5" className="die-pip pos-6-5" />);
        pips.push(<div key="6" className="die-pip pos-6-6" />);
      } else if (value === 7) {
        pips.push(<div key="1" className="die-pip pos-7-1" />);
        pips.push(<div key="2" className="die-pip pos-7-2" />);
        pips.push(<div key="3" className="die-pip pos-7-3" />);
        pips.push(<div key="4" className="die-pip pos-7-4" />);
        pips.push(<div key="5" className="die-pip pos-7-5" />);
        pips.push(<div key="6" className="die-pip pos-7-6" />);
        pips.push(<div key="7" className="die-pip pos-7-7" />);
      } else if (value === 8) {
        pips.push(<div key="1" className="die-pip pos-8-1" />);
        pips.push(<div key="2" className="die-pip pos-8-2" />);
        pips.push(<div key="3" className="die-pip pos-8-3" />);
        pips.push(<div key="4" className="die-pip pos-8-4" />);
        pips.push(<div key="5" className="die-pip pos-8-5" />);
        pips.push(<div key="6" className="die-pip pos-8-6" />);
        pips.push(<div key="7" className="die-pip pos-8-7" />);
        pips.push(<div key="8" className="die-pip pos-8-8" />);
      }
      
      return pips;
    }

    // Components
    function getDiceTypeInfo(diceType) {
      const typeInfo = {
        "all_two": { name: "Ìä∏Î¶¨Ìîå Îã§Ïù¥Ïä§", faces: [3,3,3,3,3,3] },
        "extreme": { name: "ÏùµÏä§Ìä∏Î¶º Îã§Ïù¥Ïä§", faces: [0,0,0,6,6,6] },
        "even": { name: "ÏßùÏàò Îã§Ïù¥Ïä§", faces: [2,2,4,4,6,6] },
        "odd": { name: "ÌôÄÏàò Îã§Ïù¥Ïä§", faces: [1,3,3,3,5,5] },
        "middle": { name: "Ï§ëÍ∞Ñ Îã§Ïù¥Ïä§", faces: [3,3,3,4,4,4] },
        "d8": { name: "Ï∞®Ïõê ÏôúÍ≥°", faces: [1,2,3,4,5,6,7,8] },
        "d6_2_7": { name: "ÏïàÏ†ïÏ†ÅÏù∏ ÏóîÏßÑ", faces: [2,3,4,5,6,7] },
        "dice_6_1": { name: "6¬∑1 Îã§Ïù¥Ïä§", faces: [6,6,2,2,1,1] },
        "dice_6_0": { name: "6¬∑0 Îã§Ïù¥Ïä§", faces: [6,6,6,0,0,0] },
        "dice_5_3": { name: "5¬∑3 Îã§Ïù¥Ïä§", faces: [5,5,5,3,3,3] },
        "dice_5_2": { name: "5¬∑2 Îã§Ïù¥Ïä§", faces: [5,5,5,2,2,2] },
        "dice_5_1": { name: "5¬∑1 Îã§Ïù¥Ïä§", faces: [5,5,5,1,1,1] },
        "dice_4_3": { name: "4¬∑3 Îã§Ïù¥Ïä§", faces: [4,4,4,3,3,3] },
        "dice_4_2": { name: "4¬∑2 Îã§Ïù¥Ïä§", faces: [4,4,4,2,2,2] },
        "dice_6_4_2": { name: "6¬∑4¬∑2 Îã§Ïù¥Ïä§", faces: [6,6,2,2,4,4] },
        "dice_5_4_3": { name: "5¬∑4¬∑3 Îã§Ïù¥Ïä§", faces: [5,5,3,3,4,4] },
        "dice_6_5_1": { name: "6¬∑5¬∑1 Îã§Ïù¥Ïä§", faces: [6,6,1,1,5,5] },
        "dice_6_4_1": { name: "6¬∑4¬∑1 Îã§Ïù¥Ïä§", faces: [6,6,1,1,4,4] },
        "dice_5_4_2": { name: "5¬∑4¬∑2 Îã§Ïù¥Ïä§", faces: [5,5,2,2,4,4] },
        "dice_6_4_0": { name: "6¬∑4¬∑0 Îã§Ïù¥Ïä§", faces: [6,6,0,0,4,4] },
        "dice_5_4_1": { name: "5¬∑4¬∑1 Îã§Ïù¥Ïä§", faces: [5,5,4,4,1,1] },
        "dice_6_3_1": { name: "6¬∑3¬∑1 Îã§Ïù¥Ïä§", faces: [6,6,3,3,1,1] },
        "dice_5_3_2": { name: "5¬∑3¬∑2 Îã§Ïù¥Ïä§", faces: [5,5,3,3,2,2] },
        "dice_5_4_0": { name: "5¬∑4¬∑0 Îã§Ïù¥Ïä§", faces: [5,5,0,0,4,4] },
        "dice_6_3_0": { name: "6¬∑3¬∑0 Îã§Ïù¥Ïä§", faces: [6,6,3,3,0,0] },
        "dice_5_3_1": { name: "5¬∑3¬∑1 Îã§Ïù¥Ïä§", faces: [5,5,3,3,1,1] },
        "dice_4_3_2": { name: "4¬∑3¬∑2 Îã§Ïù¥Ïä§", faces: [4,4,3,3,2,2] },
        "dice_6_2_1": { name: "6¬∑2¬∑1 Îã§Ïù¥Ïä§", faces: [6,6,2,2,1,1] },
        "abyss_cursed": { name: "Ïã¨Ïó∞Ïùò Ï†ÄÏ£º", faces: [0,0,0,0,0,0] },
      };
      return typeInfo[diceType] || null;
    }

    function Die({ value, isSelected, isStunned, isRolling, diceType, onToggle, selectionDisabled, index, enhancementLevel = 0, previewValue = null, isCursed = false }) {
      const [displayValue, setDisplayValue] = useState(value);
      const diceTypeInfo = getDiceTypeInfo(diceType);
      const isSpecialDice = diceTypeInfo !== null;
      
      useEffect(() => {
        if (isRolling) {
          // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ë Í∞íÏù¥ ÎûúÎç§ÌïòÍ≤å Î∞îÎÄåÎäî Ìö®Í≥º
          const interval = setInterval(() => {
            const randomValue = Math.floor(Math.random() * 6) + 1;
            setDisplayValue(randomValue);
          }, 100);
          return () => clearInterval(interval);
        } else {
          setDisplayValue(value);
        }
      }, [isRolling, value]);
      
      const showPreview = previewValue != null && !isRolling;
      const valueToShow = showPreview ? previewValue : displayValue;
      
      const dieClass = `die ${isSelected ? 'selected' : ''} ${isStunned ? 'stunned' : ''} ${isRolling ? 'rolling' : ''} ${isSpecialDice ? 'special-dice' : ''} ${enhancementLevel > 0 ? 'enhanced' : ''} ${isCursed ? 'cursed' : ''}`;
      const animationDelay = isRolling ? `${index * 0.05}s` : '0s';
      
      return (
        <div 
          className={dieClass} 
          onClick={!selectionDisabled && !isRolling && onToggle}
          style={{ animationDelay, ...(showPreview ? { opacity: 0.5, transition: 'opacity 0.15s ease' } : {}), ...(isCursed ? { boxShadow: 'inset 0 0 0 2px #a855f7' } : {}) }}
        >
          {renderDicePips(valueToShow)}
          {isStunned && <div className="stun-badge" />}
          {isCursed && <div style={{ position: 'absolute', bottom: 2, left: '50%', transform: 'translateX(-50%)', fontSize: '0.6rem', color: '#a855f7', fontWeight: 'bold' }}>Ï†ÄÏ£º</div>}
          {enhancementLevel > 0 && (
            <div style={{ position: 'absolute', top: '2px', right: '2px', background: 'linear-gradient(135deg, #fbbf24, #f59e0b)', color: 'white', borderRadius: '50%', width: '20px', height: '20px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.75rem', fontWeight: 'bold', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)', zIndex: 10 }}>
              +{enhancementLevel}
            </div>
          )}
          {isSpecialDice && (
            <div className="die-tooltip">
              <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{diceTypeInfo.name}</div>
              <div>ÎààÍ∏à: {diceTypeInfo.faces.join(', ')}</div>
            </div>
          )}
        </div>
      );
    }

    function Monster({ name, nameKo, maxHp, currentHp, showDamage, damage, isMonsterAttacking, imageUrl }) {
      const hpPercentage = Math.max(0, (currentHp / maxHp) * 100);
      const hpBarClass = `hp-bar-fill ${hpPercentage > 50 ? '' : hpPercentage > 25 ? 'medium' : 'low'}`;
      const [imageError, setImageError] = useState(false);
      
      let monsterBody;
      
      if (imageUrl && !imageError) {
        // Í∞Å Î™¨Ïä§ÌÑ∞ÎßàÎã§ Î≥ÑÎèÑ Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ¨Ïö©
        monsterBody = (
          <img 
            src={imageUrl} 
            alt={nameKo || name}
            className="monster-image"
            onError={() => setImageError(true)}
          />
        );
      } else {
        // Í∏∞Ï°¥ CSS Î∞©Ïãù (imageUrlÏù¥ ÏóÜÍ±∞ÎÇò Î°úÎìú Ïã§Ìå® Ïãú)
        if (name === "Slime" || nameKo === "Ïä¨ÎùºÏûÑ") {
          monsterBody = (
            <div className="monster-slime">
              <div className="slime-eyes">
                <div className="slime-eye" />
                <div className="slime-eye" />
              </div>
              <div className="slime-mouth" />
              <div className="slime-bubbles" />
            </div>
          );
        } else if (name === "Goblin" || nameKo === "Í≥†Î∏îÎ¶∞") {
          monsterBody = (
            <div className="monster-goblin">
              <div className="goblin-ears">
                <div className="goblin-ear-left" />
                <div className="goblin-ear-right" />
              </div>
              <div className="goblin-eyes">
                <div className="goblin-eye" />
                <div className="goblin-eye" />
              </div>
              <div className="goblin-nose" />
              <div className="goblin-mouth">
                <div className="goblin-tooth" />
                <div className="goblin-tooth" />
                <div className="goblin-tooth" />
              </div>
            </div>
          );
        } else if (name === "Orc" || nameKo === "Ïò§ÌÅ¨") {
          monsterBody = (
            <div className="monster-orc">
              <div className="orc-ears">
                <div className="orc-ear-left" />
                <div className="orc-ear-right" />
              </div>
              <div className="orc-eyes">
                <div className="orc-eye" />
                <div className="orc-eye" />
              </div>
              <div className="orc-nose" />
              <div className="orc-tusks">
                <div className="orc-tusk orc-tusk-left" />
                <div className="orc-tusk orc-tusk-right" />
              </div>
              <div className="orc-mouth" />
            </div>
          );
        } else if (name === "Dragon" || nameKo === "ÎìúÎûòÍ≥§") {
          monsterBody = (
            <div className="monster-dragon">
              <div className="dragon-horns">
                <div className="dragon-horn-left" />
                <div className="dragon-horn-right" />
              </div>
              <div className="dragon-eyes">
                <div className="dragon-eye" />
                <div className="dragon-eye" />
              </div>
              <div className="dragon-snout">
                <div className="dragon-nostrils">
                  <div className="dragon-nostril" />
                  <div className="dragon-nostril" />
                </div>
              </div>
              <div className="dragon-mouth" />
            </div>
          );
        } else if (name === "Lich" || nameKo === "Î¶¨Ïπò") {
          monsterBody = (
            <div className="monster-lich">
              <div className="lich-skull">
                <div className="lich-eyes">
                  <div className="lich-eye" />
                  <div className="lich-eye" />
                </div>
                <div className="lich-mouth" />
              </div>
              <div className="lich-robe" />
            </div>
          );
        } else if (name === "Behemoth" || nameKo === "Î≤†ÌûàÎ™®Ïä§") {
          monsterBody = (
            <div className="monster-behemoth">
              <div className="behemoth-horns">
                <div className="behemoth-horn behemoth-horn-left" />
                <div className="behemoth-horn behemoth-horn-right" />
              </div>
              <div className="behemoth-head">
                <div className="behemoth-eyes">
                  <div className="behemoth-eye" />
                  <div className="behemoth-eye" />
                </div>
                <div className="behemoth-mouth" />
              </div>
            </div>
          );
        } else if (name === "Archdemon" || nameKo === "ÏïÑÌÅ¨Îç∞Î™¨") {
          monsterBody = (
            <div className="monster-archdemon">
              <div className="archdemon-wings">
                <div className="archdemon-wing archdemon-wing-left" />
                <div className="archdemon-wing archdemon-wing-right" />
              </div>
              <div className="archdemon-head">
                <div className="archdemon-eyes">
                  <div className="archdemon-eye" />
                  <div className="archdemon-eye" />
                </div>
                <div className="archdemon-mouth" />
              </div>
            </div>
          );
        } else if (name === "Chaos Lord" || nameKo === "Ïπ¥Ïò§Ïä§ Î°úÎìú") {
          monsterBody = (
            <div className="monster-chaos">
              <div className="chaos-aura" />
              <div className="chaos-crown" />
              <div className="chaos-eyes">
                <div className="chaos-eye" />
                <div className="chaos-eye" />
              </div>
              <div className="chaos-mouth">
                <div className="chaos-teeth">
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                  <div className="chaos-tooth" />
                </div>
              </div>
            </div>
          );
        } else {
          monsterBody = (
            <div className="monster-king">
              <div className="king-aura" />
              <div className="king-crown" />
              <div className="king-eyes">
                <div className="king-eye" />
                <div className="king-eye" />
              </div>
              <div className="king-mouth">
                <div className="king-teeth">
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                  <div className="king-tooth" />
                </div>
              </div>
            </div>
          );
        }
      }
      
      return (
        <div className="monster-container">
          <div className={`monster-body ${isMonsterAttacking ? 'attacking' : ''}`}>
            {monsterBody}
            <div style={{ marginTop: '0.75rem', fontSize: '1.125rem', fontWeight: 'bold', color: '#1e293b' }}>{nameKo || name}</div>
            {isMonsterAttacking && (
              <div className="monster-attack-effect">
                <div className="monster-attack-flash" />
              </div>
            )}
          </div>
          <div className="hp-bar-container">
            <div className="hp-label">
              <span>HP</span>
              <span>{Math.max(0, currentHp)} / {maxHp}</span>
            </div>
            <div className="hp-bar-bg">
              <div className={hpBarClass} style={{ width: `${hpPercentage}%` }} />
            </div>
            {showDamage && damage > 0 && (
              <div style={{ textAlign: 'center', marginTop: '0.5rem', fontSize: '2rem', fontWeight: 'bold', color: '#ef4444' }}>
                -{damage}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Main Game Component
    function Game() {
      const [playerState, setPlayerState] = useState(getInitialPlayerState);
      const [currentDice, setCurrentDice] = useState(() => {
        const initialDiceCount = getInitialPlayerState().diceTypes.length;
        return Array.from({ length: initialDiceCount }, (_, i) => i + 1);
      });
      const [diceFaceIndices, setDiceFaceIndices] = useState(() => {
        const n = getInitialPlayerState().diceTypes.length;
        return Array.from({ length: n }, (_, i) => i);
      });
      const [selectedIndices, setSelectedIndices] = useState(new Set());
      const [rerollsLeft, setRerollsLeft] = useState(2);
      const [roundStarted, setRoundStarted] = useState(false);
      
      const currentStage = STAGES[playerState.currentStage - 1];
      const [monsterHp, setMonsterHp] = useState(currentStage.hp);
      const [lastDamage, setLastDamage] = useState(0);
      const [showDamage, setShowDamage] = useState(false);
      const [attackResult, setAttackResult] = useState(null);
      const [showAttackResult, setShowAttackResult] = useState(false);
      
      const [stunnedIndices, setStunnedIndices] = useState(new Set());
      const [beingStunnedIndex, setBeingStunnedIndex] = useState(null);
      const [showCounterattack, setShowCounterattack] = useState(false);
      const [isMonsterAttacking, setIsMonsterAttacking] = useState(false);
      const [isPlayerAttacking, setIsPlayerAttacking] = useState(false);
      const [showRerollWarning, setShowRerollWarning] = useState(false);
      const [showDiceModifyWarning, setShowDiceModifyWarning] = useState(false);
      const [isHoveringFlipButton, setIsHoveringFlipButton] = useState(false);
      const [isRolling, setIsRolling] = useState(false);
      const [rollingDice, setRollingDice] = useState(new Set());
      
      const [showRewardSelection, setShowRewardSelection] = useState(false);
      const [rewardOptions, setRewardOptions] = useState([]);
      const [showVictory, setShowVictory] = useState(false);
      const [showEnhancementChoice, setShowEnhancementChoice] = useState(false);
      const [enhancementOffer, setEnhancementOffer] = useState(null);
      const [showMonsterPreview, setShowMonsterPreview] = useState(false);
      const [currentBossType, setCurrentBossType] = useState(null);
      const [lastUsedCombination, setLastUsedCombination] = useState(null);
      const [rerollWarningMessage, setRerollWarningMessage] = useState("Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî");
      const [cursedDiceIndex, setCursedDiceIndex] = useState(null);
      const [lastEnhancementChoice, setLastEnhancementChoice] = useState("");

      const totalDiceCount = playerState.diceTypes.length;
      const isBossStage = !!(currentStage?.isBoss && currentBossType);
      const bossInfo = isBossStage ? BOSS_TYPES_ALL.find(b => b.id === currentBossType) : null;
      const stunnedDiceCount = stunnedIndices.size;
      const normalDiceCount = totalDiceCount - stunnedDiceCount;
      const effectiveMaxRerolls = Math.max(0, playerState.baseRerolls - (currentBossType === 'reroll_minus1' ? 1 : 0));

      // ÎùºÏö¥ÎìúÍ∞Ä ÏãúÏûëÎêòÏßÄ ÏïäÏïòÏùÑ Îïå Ï£ºÏÇ¨ÏúÑÎ•º ÏàúÏÑúÎåÄÎ°ú ÌëúÏãú
      useEffect(() => {
        if (!roundStarted) {
          setCurrentDice(Array.from({ length: totalDiceCount }, (_, i) => i + 1));
          setDiceFaceIndices(Array.from({ length: totalDiceCount }, (_, i) => i));
        }
      }, [roundStarted, totalDiceCount]);

      useEffect(() => {
        const stage = STAGES[playerState.currentStage - 1];
        if (stage) setMonsterHp(stage.hp);
      }, [playerState.currentStage]);


      const currentScore = useMemo(() => {
        return calculateScore(currentDice, { 
          ownedRewards: playerState.ownedRewards,
          monsterHp: monsterHp,
          maxMonsterHp: currentStage.hp,
          diceEnhancements: playerState.diceEnhancements || [],
          combinationBoosts: playerState.combinationBoosts || {},
          usedFlipThisRound: playerState.usedFlipThisRound
        });
      }, [currentDice, playerState.ownedRewards, playerState.diceEnhancements, playerState.combinationBoosts, playerState.usedFlipThisRound, monsterHp, currentStage]);

      const toggleSelect = (index) => {
        if (!roundStarted) return;
        const hasDiceModifyStacks = (playerState.diceFlipStacks > 0);
        if (rerollsLeft === 0 && !hasDiceModifyStacks) return;
        setSelectedIndices(prev => {
          const newSet = new Set(prev);
          if (newSet.has(index)) newSet.delete(index);
          else {
            if (currentBossType === 'reroll_max2' && prev.size >= 2) return prev;
            newSet.add(index);
          }
          return newSet;
        });
      };

      const executeCounterattack = useCallback((attackDice, usedCombination) => {
        const activeIndices = Array.from({ length: totalDiceCount }, (_, i) => i).filter(i => !stunnedIndices.has(i));
        if (activeIndices.length === 0) {
          setRoundStarted(false);
          setSelectedIndices(new Set());
          setRerollsLeft(effectiveMaxRerolls);
          return;
        }
        setShowCounterattack(true);
        setIsMonsterAttacking(true);
        setTimeout(() => {
          let indicesToStun = [];
          // Í∏∞Î≥∏: Î∞òÍ≤© Ïãú Ï£ºÏÇ¨ÏúÑ 1Í∞ú Í∏∞Ï†à
          if (activeIndices.length > 0)
            indicesToStun.push(activeIndices[Math.floor(Math.random() * activeIndices.length)]);
          // combo_out_stun Ï∂îÍ∞Ä: Ï°±Î≥¥Ïóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùÄ Ï£ºÏÇ¨ÏúÑ Ï§ë 1Í∞ú Ï∂îÍ∞Ä Í∏∞Ï†à (Ïù¥ÎØ∏ ÎΩëÏùÄ Í≤É Ï†úÏô∏)
          if (currentBossType === 'combo_out_stun' && attackDice && usedCombination) {
            const comboIndices = getComboIndices(attackDice, usedCombination, { ownedRewards: playerState.ownedRewards });
            const notInCombo = activeIndices.filter(i => !comboIndices.includes(i) && !indicesToStun.includes(i));
            if (notInCombo.length > 0)
              indicesToStun.push(notInCombo[Math.floor(Math.random() * notInCombo.length)]);
          }
          // Ï£ºÏÇ¨ÏúÑ Î≥¥Ìò∏Îßâ: Í∏∞Ï†à 1Ìöå Î¨¥Ìö®
          const si = playerState.shieldIndex;
          if (si != null && !playerState.shieldUsed && indicesToStun.includes(si)) {
            indicesToStun = indicesToStun.filter(i => i !== si);
            setPlayerState(prev => ({ ...prev, shieldUsed: true }));
          }
          if (indicesToStun.length > 0) {
            setBeingStunnedIndex(indicesToStun[0]);
            setTimeout(() => {
              if (currentBossType === 'abyss_curse') {
                setPlayerState(prev => {
                  const next = { ...prev, diceTypes: [...prev.diceTypes] };
                  indicesToStun.forEach(i => { next.diceTypes[i] = 'abyss_cursed'; });
                  return next;
                });
                setCurrentDice(prev => { const n = [...prev]; indicesToStun.forEach(i => n[i] = 0); return n; });
                setDiceFaceIndices(prev => { const n = [...prev]; indicesToStun.forEach(i => n[i] = 0); return n; });
              }
              setStunnedIndices(prev => new Set([...Array.from(prev), ...indicesToStun]));
              setBeingStunnedIndex(null);
              setShowCounterattack(false);
              setIsMonsterAttacking(false);
              setRoundStarted(false);
              setSelectedIndices(new Set());
              setRerollsLeft(effectiveMaxRerolls);
            }, 800);
          } else {
            setShowCounterattack(false);
            setIsMonsterAttacking(false);
            setRoundStarted(false);
            setSelectedIndices(new Set());
            setRerollsLeft(effectiveMaxRerolls);
          }
        }, 500);
      }, [stunnedIndices, totalDiceCount, effectiveMaxRerolls, playerState, currentBossType]);

      const proceedToRewardSelection = useCallback(() => {
        const excludeIds = [...playerState.ownedRewards];
        const finalRewards = getRandomRewards(3, excludeIds, playerState.currentStage);
        setRewardOptions(finalRewards);
        setShowEnhancementChoice(false);
        setEnhancementOffer(null);
        setShowRewardSelection(true);
      }, [playerState.ownedRewards, playerState.currentStage]);

      const handleMonsterDefeated = useCallback(() => {
        if (playerState.currentStage >= STAGES.length) {
          sendBattleLog(playerState.currentStage, currentBossType, "clear", "", "");
          setShowVictory(true);
          triggerVictoryConfetti();
        } else {
          setPlayerState(prev => {
            let n = prev;
            if (n.ownedRewards.includes('random_combo_boost')) {
              const k = Object.keys(COMBINATIONS)[Math.floor(Math.random() * Object.keys(COMBINATIONS).length)];
              n = { ...n, combinationBoosts: { ...(n.combinationBoosts || {}), [k]: ((n.combinationBoosts || {})[k] || 0) + 1 } };
            }
            if (n.ownedRewards.includes('dice_flip_gain')) {
              n = { ...n, diceFlipStacks: Math.min((n.diceFlipStacks || 1) + 1, 99) };
            }
            return n;
          });
          const nonStunnedCount = Math.max(0, playerState.diceTypes.length - stunnedIndices.size);
          setEnhancementOffer({ 
            nonStunnedCount, 
            enhancementGroups: [...ENHANCEMENT_GROUPS].sort(() => Math.random() - 0.5).slice(0, 2) 
          });
          setShowEnhancementChoice(true);
        }
      }, [playerState.currentStage, playerState.diceTypes.length, stunnedIndices, currentBossType]);

      const executeAttack = useCallback((dice) => {
        setIsPlayerAttacking(true);
        const score = calculateScore(dice, { 
          ownedRewards: playerState.ownedRewards,
          monsterHp: monsterHp,
          maxMonsterHp: currentStage.hp,
          diceEnhancements: playerState.diceEnhancements || [],
          combinationBoosts: playerState.combinationBoosts || {},
          usedFlipThisRound: playerState.usedFlipThisRound
        });
        setAttackResult(score);
        setShowAttackResult(true);
        if (!score.isCursed) triggerConfetti(score);
        
        setTimeout(() => {
          setIsPlayerAttacking(false);
        }, 600);
        
        let actualDamage = score.total;
        // Í≥ºÏûâ ÎààÍ∏à Î≥¥Ïä§: Ï£ºÏÇ¨ÏúÑ Ìï©(Í∞ïÌôî Ï†úÏô∏) 21 Ï¥àÍ≥º Ïãú ÌîºÌï¥ 0
        if (currentBossType === 'over21_zero' && (score.sum - (score.enhancementBonus || 0)) > 21) {
          actualDamage = 0;
        } else if (currentBossType === 'pattern_limit' && lastUsedCombination !== null && score.combination === lastUsedCombination) {
          actualDamage = 0;
        } else if (currentBossType === 'damage_cap_50') {
          const cap = Math.floor(currentStage.hp * 0.5);
          actualDamage = Math.min(score.total, cap);
        } else if (currentBossType === 'cursed_dice' && cursedDiceIndex != null && getComboIndices(dice, score.combination, { ownedRewards: playerState.ownedRewards }).includes(cursedDiceIndex)) {
          actualDamage = 0;
        }
        setLastUsedCombination(score.combination);
        const newHp = Math.max(0, monsterHp - actualDamage);
        setTimeout(() => {
          setLastDamage(actualDamage);
          setShowDamage(true);
          setMonsterHp(newHp);
          setTimeout(() => setShowDamage(false), 1000);
          if (playerState.ownedRewards.includes('random_die_enhance') && actualDamage > 0 && dice.length > 0) {
            setPlayerState(prev => {
              const e = [...(prev.diceEnhancements || [])];
              while (e.length < prev.diceTypes.length) e.push(0);
              const i = Math.floor(Math.random() * e.length);
              e[i] = (e[i] || 0) + 1;
              return { ...prev, diceEnhancements: e };
            });
          }
        }, 800);
        
        setTimeout(() => {
          setShowAttackResult(false);
          setAttackResult(null);
          if (newHp <= 0) {
            setRoundStarted(false);
            setSelectedIndices(new Set());
            setRerollsLeft(effectiveMaxRerolls);
            // Ï†ÑÌà¨ Ï¢ÖÎ£å: Îí§ÏßëÍ∏∞ Ïä§ÌÉù +1 (ÏµúÎåÄ 3)
            setPlayerState(prev => ({
              ...prev,
              diceFlipStacks: Math.min((prev.diceFlipStacks || 0) + 1, 3)
            }));
            handleMonsterDefeated();
          } else {
            executeCounterattack(dice, score.combination);
          }
        }, 2000);
      }, [monsterHp, currentStage, currentBossType, lastUsedCombination, executeCounterattack, playerState.ownedRewards, effectiveMaxRerolls, handleMonsterDefeated, stunnedIndices, cursedDiceIndex]);

      const rollCustomDice = useCallback(() => {
        const forceFullReroll = playerState.holdDisabled;
        const newDice = [];
        const newFaceIndices = [];
        playerState.diceTypes.forEach((type, idx) => {
          const isStunned = stunnedIndices.has(idx);
          if (forceFullReroll || selectedIndices.has(idx) || isStunned) {
            const { value, faceIndex } = rollDieWithIndex(type, isStunned);
            newDice.push(value);
            newFaceIndices.push(faceIndex);
          } else {
            newDice.push(currentDice[idx]);
            newFaceIndices.push(diceFaceIndices[idx] ?? 0);
          }
        });
        return { newDice, newFaceIndices };
      }, [playerState.diceTypes, playerState.holdDisabled, selectedIndices, stunnedIndices, currentDice, diceFaceIndices]);

      const handleInitialRoll = () => {
        setPlayerState(prev => ({ ...prev, usedFlipThisRound: false }));
        setSelectedIndices(new Set());
        setRerollsLeft(effectiveMaxRerolls);
        if (currentBossType === 'cursed_dice' && totalDiceCount > 0)
          setCursedDiceIndex(Math.floor(Math.random() * totalDiceCount));
        setRoundStarted(true);
        setShowAttackResult(false);
        setAttackResult(null);
        
        // Î™®Îì† Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î¶¨Îäî Ï§ëÏúºÎ°ú ÏÑ§Ï†ï
        setIsRolling(true);
        setRollingDice(new Set(Array.from({ length: totalDiceCount }, (_, i) => i)));
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Ï£ºÏÇ¨ÏúÑ Í∞í ÏóÖÎç∞Ïù¥Ìä∏
        setTimeout(() => {
          const newDice = [];
          const newFaceIndices = [];
          playerState.diceTypes.forEach((type, idx) => {
            const isStunned = stunnedIndices.has(idx);
            const { value, faceIndex } = rollDieWithIndex(type, isStunned);
            newDice.push(value);
            newFaceIndices.push(faceIndex);
          });
          setCurrentDice(newDice);
          setDiceFaceIndices(newFaceIndices);
          setIsRolling(false);
          setRollingDice(new Set());
        }, 600);
      };

      const handleReroll = () => {
        if (rerollsLeft <= 0) return;
        const forceFullReroll = playerState.holdDisabled;

        // Î¶¨Î°§ 2Í∞ú Ï†úÌïú Î≥¥Ïä§: 3Í∞ú Ïù¥ÏÉÅ ÎèôÏãú Î¶¨Î°§ Î∂àÍ∞Ä (ÏÑ†ÌÉùÏùÄ toggleSelectÏóêÏÑú 2Í∞úÎ°ú Ï†úÌïú)
        if (currentBossType === 'reroll_max2' && (forceFullReroll ? totalDiceCount >= 3 : selectedIndices.size > 2)) {
          setRerollWarningMessage("3Í∞ú Ïù¥ÏÉÅ ÎèôÏãú Î¶¨Î°§ Î∂àÍ∞Ä");
          setShowRerollWarning(true);
          setTimeout(() => setShowRerollWarning(false), 2000);
          return;
        }

        const diceToRoll = new Set();
        playerState.diceTypes.forEach((type, idx) => {
          const isStunned = stunnedIndices.has(idx);
          if (forceFullReroll || selectedIndices.has(idx) || isStunned) {
            diceToRoll.add(idx);
          }
        });

        if (!forceFullReroll && diceToRoll.size === 0) {
          setRerollWarningMessage("Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî");
          setShowRerollWarning(true);
          setTimeout(() => setShowRerollWarning(false), 2000);
          return;
        }
        
        setIsRolling(true);
        setRollingDice(diceToRoll);
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Ï£ºÏÇ¨ÏúÑ Í∞í ÏóÖÎç∞Ïù¥Ìä∏
        setTimeout(() => {
          let { newDice, newFaceIndices } = rollCustomDice();
          setCurrentDice(newDice);
          setDiceFaceIndices(newFaceIndices);
          setSelectedIndices(new Set());
          setRerollsLeft(prev => prev - 1);
          if (currentBossType === 'despair_heal') {
            setMonsterHp(prev => Math.min(currentStage.hp, prev + Math.ceil(currentStage.hp * 0.1)));
          }
          if (playerState.ownedRewards.includes('reroll_burn')) {
            const burnSum = Array.from(diceToRoll).reduce((s, i) => s + (newDice[i] || 0) + ((playerState.diceEnhancements || [])[i] || 0), 0);
            setMonsterHp(prev => Math.max(0, prev - burnSum));
          }
          setIsRolling(false);
          setRollingDice(new Set());
        }, 600);
      };

      const goToNextStage = (stateAfterReward, rewardChoice) => {
        sendBattleLog(stateAfterReward.currentStage, currentBossType, "win", lastEnhancementChoice || "", rewardChoice || "");
        setLastEnhancementChoice("");
        const newState = { ...stateAfterReward };
        newState.currentStage += 1;
        if (newState.shieldIndex != null) newState.shieldUsed = false;
        const newDiceCount = newState.diceTypes.length;
        const cur = newState.diceEnhancements || [];
        if (cur.length !== newDiceCount) {
          newState.diceEnhancements = newDiceCount > cur.length
            ? [...cur, ...Array(newDiceCount - cur.length).fill(0)]
            : cur.slice(0, newDiceCount);
        }
        setPlayerState(newState);
        setShowRewardSelection(false);
        setStunnedIndices(new Set());
        setCurrentDice(Array.from({ length: newDiceCount }, (_, i) => i + 1));
        setDiceFaceIndices(Array.from({ length: newDiceCount }, (_, i) => i));
        const nextStage = STAGES[newState.currentStage - 1];
        if (nextStage) setMonsterHp(nextStage.hp);
        let nextBossId = null;
        if (newState.currentStage === 2) {
          const pool = BOSS_TYPES_STAGE_2;
          nextBossId = pool[Math.floor(Math.random() * pool.length)].id;
        } else if (newState.currentStage === 4) {
          const pool = BOSS_TYPES_STAGE_4;
          nextBossId = pool[Math.floor(Math.random() * pool.length)].id;
        } else if (newState.currentStage === 6) {
          const pool = BOSS_TYPES_STAGE_6;
          nextBossId = pool[Math.floor(Math.random() * pool.length)].id;
        } else if (newState.currentStage === 8) {
          const pool = BOSS_TYPES_STAGE_8;
          nextBossId = pool[Math.floor(Math.random() * pool.length)].id;
        }
        setCurrentBossType(nextBossId);
        setRerollsLeft(Math.max(0, newState.baseRerolls - (nextBossId === 'reroll_minus1' ? 1 : 0)));
        setLastUsedCombination(null);
        setCursedDiceIndex(null);
      };

      const handleSelectReward = (reward) => {
        if (playerState.ownedRewards.includes(reward.id)) return;
        const stateAfterReward = applyReward(playerState, reward.id);
        goToNextStage(stateAfterReward, reward.id);
      };

      const handleRestart = () => {
        const initialState = getInitialPlayerState();
        setPlayerState(initialState);
        const initialDiceCount = initialState.diceTypes.length;
        setCurrentDice(Array.from({ length: initialDiceCount }, (_, i) => i + 1));
        setDiceFaceIndices(Array.from({ length: initialDiceCount }, (_, i) => i));
        setSelectedIndices(new Set());
        setRerollsLeft(initialState.baseRerolls);
        setRoundStarted(false);
        setStunnedIndices(new Set());
        setMonsterHp(STAGES[0].hp);
        setShowVictory(false);
        setShowRewardSelection(false);
        setShowEnhancementChoice(false);
        setEnhancementOffer(null);
        setCurrentBossType(null);
        setLastUsedCombination(null);
        setCursedDiceIndex(null);
      };

      const canReroll = roundStarted && rerollsLeft > 0 && !showAttackResult && !showCounterattack;
      const canAttack = roundStarted && !showAttackResult && !showCounterattack;
      const isMonsterDefeated = monsterHp <= 0;
      const allDiceStunned = normalDiceCount <= 0;

      return (
        <div className="container">
          <main className="main-game">
            <div className="bg-decoration bg-1" />
            <div className="bg-decoration bg-2" />
            
            <div className="stage-indicator">
              <span className="stage-badge">Stage {playerState.currentStage} / 8{currentStage?.isBoss ? ' (Î≥¥Ïä§)' : ''}</span>
              {playerState.diceFlipStacks > 0 && (
                <div style={{
                  background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
                  color: 'white',
                  padding: '0.25rem 0.75rem',
                  borderRadius: '9999px',
                  fontSize: '0.875rem',
                  fontWeight: 'bold',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.25rem',
                  marginLeft: '0.5rem'
                }}>
                  <span>üîÑ</span>
                  <span>{playerState.diceFlipStacks}</span>
                </div>
              )}
              <button 
                className="btn" 
                onClick={() => setShowMonsterPreview(true)}
                style={{ 
                  marginLeft: '1rem', 
                  padding: '0.5rem 1rem', 
                  fontSize: '0.875rem',
                  background: 'rgba(99, 102, 241, 0.1)',
                  border: '1px solid rgba(99, 102, 241, 0.3)'
                }}
              >
                Î™¨Ïä§ÌÑ∞ ÎØ∏Î¶¨Î≥¥Í∏∞
              </button>
            </div>

            {bossInfo && (
              <div style={{
                marginBottom: '1rem',
                padding: '0.75rem 1rem',
                background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(99, 102, 241, 0.15))',
                border: '1px solid rgba(139, 92, 246, 0.4)',
                borderRadius: '0.75rem',
                fontSize: '0.875rem'
              }}>
                <div style={{ fontWeight: 'bold', marginBottom: '0.25rem', color: '#a78bfa' }}>üëπ Î≥¥Ïä§ ÌäπÏÑ±: {bossInfo.nameKo}</div>
                <div style={{ color: 'rgba(30, 41, 59, 0.9)' }}>{bossInfo.descriptionKo}</div>
              </div>
            )}
            
            <div className="monster-section">
              <Monster name={currentStage.name} nameKo={currentStage.nameKo} maxHp={currentStage.hp} currentHp={monsterHp} showDamage={showDamage} damage={lastDamage} isMonsterAttacking={isMonsterAttacking} imageUrl={currentStage.imageUrl} />
            </div>

            {showMonsterPreview && (
              <div className="modal-overlay" onClick={() => setShowMonsterPreview(false)}>
                <div className="modal" onClick={(e) => e.stopPropagation()} style={{ maxWidth: '900px', maxHeight: '90vh', overflow: 'auto' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                    <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>Î™¨Ïä§ÌÑ∞ ÎØ∏Î¶¨Î≥¥Í∏∞</h2>
                    <button 
                      className="btn" 
                      onClick={() => setShowMonsterPreview(false)}
                      style={{ padding: '0.5rem 1rem' }}
                    >
                      Îã´Í∏∞
                    </button>
                  </div>
                  <div style={{ 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', 
                    gap: '2rem',
                    padding: '1rem'
                  }}>
                    {STAGES.map(stage => (
                      <div key={stage.id} style={{ 
                        display: 'flex', 
                        flexDirection: 'column', 
                        alignItems: 'center',
                        background: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '1rem',
                        padding: '1.5rem'
                      }}>
                        <Monster 
                          name={stage.name} 
                          nameKo={stage.nameKo} 
                          maxHp={stage.hp} 
                          currentHp={stage.hp} 
                          showDamage={false} 
                          damage={0} 
                          isMonsterAttacking={false} 
                          imageUrl={stage.imageUrl} 
                        />
                        <div style={{ marginTop: '0.5rem', fontSize: '0.875rem', color: 'rgba(255,255,255,0.8)' }}>
                          Stage {stage.id}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {showVictory && (
              <div className="modal-overlay" onClick={handleRestart}>
                <div className="modal">
                  <h2 style={{ fontSize: '2rem', fontWeight: 'bold', marginBottom: '1rem' }}>üéâ ÏäπÎ¶¨! üéâ</h2>
                  <p style={{ marginBottom: '1.5rem' }}>Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄÎ•º ÌÅ¥Î¶¨Ïñ¥ÌñàÏäµÎãàÎã§!</p>
                  <button className="btn btn-attack" onClick={handleRestart}>Îã§Ïãú ÏãúÏûë</button>
                </div>
              </div>
            )}

            {showEnhancementChoice && enhancementOffer && (
              <div className="modal-overlay">
                <div className="modal" style={{ maxWidth: '560px', maxHeight: '90vh', overflow: 'auto' }}>
                  <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem' }}>‚¨Ü Í∞ïÌôî ÏÑ†ÌÉù</h2>
                  <p style={{ fontSize: '0.875rem', color: 'rgba(255,255,255,0.9)', marginBottom: '1.25rem' }}>ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</p>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.75rem' }}>
                    {(enhancementOffer.enhancementGroups || ENHANCEMENT_GROUPS).map(grp => (
                      <button
                        key={grp.id}
                        className="btn"
                        onClick={() => {
                          setLastEnhancementChoice(grp.id);
                          setPlayerState(prev => {
                            const next = { ...prev, combinationBoosts: { ...(prev.combinationBoosts || {}) } };
                            grp.comboKeys.forEach(k => { next.combinationBoosts[k] = (next.combinationBoosts[k] || 0) + 1; });
                            return next;
                          });
                          proceedToRewardSelection();
                        }}
                        style={{ padding: '0.875rem 1rem', fontSize: '0.95rem', background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)' }}
                      >
                        {grp.labelKo}
                        <span style={{ fontSize: '0.8rem', opacity: 0.9, display: 'block', marginTop: '0.2rem' }}>
                          {grp.comboKeys.map(k => {
                            const base = COMBINATIONS[k].multiplier;
                            const cur = (playerState.combinationBoosts || {})[k] || 0;
                            return <span key={k}>√ó{base + cur}‚Üí√ó{base + cur + 1} </span>;
                          })}
                        </span>
                      </button>
                    ))}
                    <button
                      className="btn"
                      onClick={() => {
                        setLastEnhancementChoice("random_dice");
                        const n = (enhancementOffer && typeof enhancementOffer.nonStunnedCount === 'number') ? enhancementOffer.nonStunnedCount : 0;
                        const len = playerState.diceTypes.length;
                        const i = len > 0 ? Math.floor(Math.random() * len) : 0;
                        setPlayerState(prev => {
                          const e = [...(prev.diceEnhancements || [])];
                          while (e.length < prev.diceTypes.length) e.push(0);
                          e[i] = (e[i] || 0) + n;
                          return { ...prev, diceEnhancements: e };
                        });
                        proceedToRewardSelection();
                      }}
                      style={{ padding: '0.875rem 1rem', fontSize: '0.95rem', background: 'linear-gradient(135deg, #059669, #047857)', gridColumn: '1 / -1' }}
                    >
                      Î¨¥ÏûëÏúÑ Ï£ºÏÇ¨ÏúÑ Ï§ë 1Í∞ú Í∞ïÌôî +{(enhancementOffer && typeof enhancementOffer.nonStunnedCount === 'number') ? enhancementOffer.nonStunnedCount : 0}
                    </button>
                  </div>
                </div>
              </div>
            )}

            {showRewardSelection && (() => {
              const isDiceVariantRound = [1, 3, 5, 7].includes(playerState.currentStage);
              return (
              <div className="modal-overlay">
                <div className="modal" style={{ maxWidth: '700px', maxHeight: '90vh', overflow: 'auto' }}>
                  <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.25rem' }}>
                    {isDiceVariantRound ? 'üé≤ Ï£ºÏÇ¨ÏúÑ Î≥ÄÌòï' : '‚ú® Ìå®ÏãúÎ∏å Î≥¥ÏÉÅ'}
                  </h2>
                  <p style={{ fontSize: '0.875rem', color: 'rgba(255,255,255,0.85)', marginBottom: '1rem' }}>
                    {isDiceVariantRound ? '1¬∑3¬∑5¬∑7Ïä§ÌÖåÏù¥ÏßÄ ‚Äì ÏùºÎ∞ò Ï£ºÏÇ¨ÏúÑ 1Í∞úÎ•º ÌäπÏàò Ï£ºÏÇ¨ÏúÑÎ°ú ÍµêÏ≤¥' : '2¬∑4¬∑6Ïä§ÌÖåÏù¥ÏßÄ ‚Äì Îä•Î†• Î≥¥ÏÉÅ'}
                  </p>
                  <div style={{ 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', 
                    gap: '1rem',
                    padding: '1rem',
                    borderRadius: '0.5rem',
                    background: isDiceVariantRound ? 'rgba(99, 102, 241, 0.12)' : 'rgba(34, 197, 94, 0.12)',
                    border: `1px solid ${isDiceVariantRound ? 'rgba(99, 102, 241, 0.35)' : 'rgba(34, 197, 94, 0.35)'}`
                  }}>
                    {rewardOptions.map(reward => {
                      const isOwned = playerState.ownedRewards.includes(reward.id);
                      const canSelect = !isOwned;
                      return (
                        <div 
                          key={reward.id} 
                          className="reward-option" 
                          style={{
                            opacity: canSelect ? 1 : 0.6,
                            cursor: canSelect ? 'pointer' : 'default',
                            background: canSelect ? 'rgba(255, 255, 255, 0.1)' : 'rgba(100, 100, 100, 0.2)'
                          }}
                        >
                          <div style={{ fontWeight: 'bold', fontSize: '1rem', marginBottom: '0.5rem' }}>{reward.nameKo}</div>
                          <div style={{ fontSize: '0.875rem', color: 'rgba(255,255,255,0.9)', marginBottom: '0.75rem' }}>
                            {reward.descriptionKo}
                          </div>
                          {isOwned ? (
                            <div style={{ textAlign: 'center', padding: '0.5rem', background: 'rgba(100, 100, 100, 0.3)', borderRadius: '0.5rem', fontSize: '0.875rem', fontWeight: 'bold' }}>
                              Ïù¥ÎØ∏ Î≥¥Ïú†
                            </div>
                          ) : (
                            <button
                              className="btn"
                              onClick={() => handleSelectReward(reward)}
                              style={{ width: '100%', padding: '0.75rem', fontSize: '0.875rem', background: 'linear-gradient(to right, #6366f1, #8b5cf6)', cursor: 'pointer' }}
                            >
                              ÏÑ†ÌÉù
                            </button>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  <div style={{ display: 'flex', gap: '1rem', marginTop: '1.25rem', paddingTop: '1rem', borderTop: '1px solid rgba(255,255,255,0.2)' }}>
                    <button
                      className="btn"
                      onClick={() => goToNextStage(playerState, "pass")}
                      style={{ flex: 1, padding: '0.875rem', fontSize: '0.95rem', background: 'rgba(100, 100, 100, 0.5)', color: 'rgba(255,255,255,0.9)' }}
                    >
                      Pass
                    </button>
                    <button
                      className="btn"
                      onClick={() => goToNextStage({ ...playerState, diceFlipStacks: Math.min((playerState.diceFlipStacks || 1) + 1, 3) }, "flip_plus1")}
                      style={{ flex: 1, padding: '0.875rem', fontSize: '0.95rem', background: 'linear-gradient(to right, #8b5cf6, #7c3aed)' }}
                    >
                      Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞+1 ÌöçÎìù
                    </button>
                  </div>
                </div>
              </div>
            );})()}

            {showCounterattack && (
              <div className="counterattack-overlay">
                <div className="counterattack-modal">
                  ‚ö° Î∞òÍ≤©! ‚ö°<br />
                  <div style={{ fontSize: '1rem', marginTop: '0.5rem', opacity: 0.9 }}>‚ö† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÌï©ÎãàÎã§...</div>
                </div>
              </div>
            )}

            {showRerollWarning && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal" style={{ background: 'linear-gradient(to right, #f59e0b, #f97316)', maxWidth: '350px', padding: '1.5rem' }}>
                  <div style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>‚ö† {rerollWarningMessage}</div>
                </div>
              </div>
            )}

            {showDiceModifyWarning && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal" style={{ background: 'linear-gradient(to right, #ef4444, #dc2626)', maxWidth: '350px', padding: '1.5rem' }}>
                  <div style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>‚ö† Ï£ºÏÇ¨ÏúÑÎ•º 1Í∞úÎßå ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî</div>
                </div>
              </div>
            )}

            {showAttackResult && attackResult && (
              <div className="modal-overlay" style={{ pointerEvents: 'none' }}>
                <div className="modal attack-result-modal" style={{ background: attackResult.isCursed ? 'linear-gradient(to right, #374151, #111827)' : `linear-gradient(to right, #6366f1, #7c3aed)` }}>
                  <div className="attack-label" style={{ fontWeight: 'bold', marginBottom: '0.5rem' }}>
                    {attackResult.isCursed ? 'CURSED!' : attackResult.labelKo.replace(/\s*\([^)]*\)/g, '')}!
                  </div>
                  <div className="attack-result" style={{ fontSize: '1.5rem' }}>
                    {!attackResult.isCursed && (attackResult.enhancementBonus || 0) > 0 ? (
                      <>({attackResult.sum - attackResult.enhancementBonus}<span style={{ color: '#fbbf24' }}> +{attackResult.enhancementBonus}</span>) √ó {attackResult.multiplier * attackResult.finalMultiplier} = {attackResult.total}</>
                    ) : (
                      <>{attackResult.sum} √ó {attackResult.multiplier * attackResult.finalMultiplier} = {attackResult.total}</>
                    )}
                  </div>
                </div>
              </div>
            )}

            <h1 className="title">Dice<span style={{ color: '#6366f1' }}>Battle</span></h1>
            <p className="subtitle">
              {!roundStarted ? "Ï£ºÏÇ¨ÏúÑÎ•º Íµ¥Î†§ Î™¨Ïä§ÌÑ∞Î•º Í≥µÍ≤©ÌïòÏÑ∏Ïöî!" : playerState.holdDisabled ? "Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Î¶¨Î°§Îê©ÎãàÎã§! Í≥µÍ≤©ÌïòÏÑ∏Ïöî!" : "Î¶¨Î°§Ìï† Ï£ºÏÇ¨ÏúÑÎ•º ÏÑ†ÌÉùÌïòÍ±∞ÎÇò Í≥µÍ≤©ÌïòÏÑ∏Ïöî!"}
            </p>

            {stunnedDiceCount > 0 && (
              <div className="stun-counter">
                ‚ö† Í∏∞Ï†àÎêú Ï£ºÏÇ¨ÏúÑ: {stunnedDiceCount} / {totalDiceCount}
                <div className="stun-tooltip">
                  Í∏∞Ï†àÎêú Ï£ºÏÇ¨ÏúÑÎäî 1,1,1,0,0,0 ÎààÍ∏àÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÍ≥† Î¶¨Î°§Ïãú Ïû¨Íµ¥Î¶ºÎê©ÎãàÎã§. Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÎêòÎ©¥ Ìå®Î∞∞Ìï©ÎãàÎã§.
                </div>
              </div>
            )}

            <div className={`dice-container ${isPlayerAttacking ? 'attacking' : ''}`}>
              {isPlayerAttacking && (
                <div className="attack-effect">
                  <div className="attack-flash" />
                </div>
              )}
              {currentDice.map((value, idx) => (
                <Die
                  key={idx}
                  index={idx}
                  value={value}
                  isSelected={selectedIndices.has(idx)}
                  isStunned={stunnedIndices.has(idx)}
                  isRolling={isRolling && rollingDice.has(idx)}
                  diceType={playerState.diceTypes[idx] || "normal"}
                  onToggle={() => toggleSelect(idx)}
                  selectionDisabled={false}
                  enhancementLevel={(playerState.diceEnhancements || [0, 0, 0, 0, 0])[idx] || 0}
                  isCursed={currentBossType === 'cursed_dice' && cursedDiceIndex === idx}
                  previewValue={playerState.diceFlipStacks > 0 && isHoveringFlipButton && selectedIndices.has(idx) && (selectedIndices.size === 1 || playerState.ownedRewards.includes('multi_flip') || currentBossType === 'flip_all') && !(isRolling && rollingDice.has(idx)) ? (() => {
                    const type = playerState.diceTypes[idx] || "normal";
                    // Í∏∞Ï†à Ï£ºÏÇ¨ÏúÑÎäî [0,0,0,1,1,1] Î©¥Îßå ÏÇ¨Ïö© (abyss_cursed Ï†úÏô∏)
                    if (stunnedIndices.has(idx) && type !== 'abyss_cursed') {
                      const faces = [0,0,0,1,1,1];
                      const i = diceFaceIndices[idx] ?? 0;
                      return faces[5 - i];
                    }
                    const faces = getDiceFaces(type);
                    if (faces) { const i = diceFaceIndices[idx] ?? 0; return faces[5 - i]; }
                    const v = currentDice[idx] ?? 0;
                    if (v >= 1 && v <= 6) return 7 - v;
                    return undefined;
                  })() : undefined}
                />
              ))}
            </div>

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (selectedIndices.size > 0 || playerState.ownedRewards.includes('flip_all_double') || currentBossType === 'flip_all') && (
              <div style={{ 
                display: 'flex', 
                justifyContent: 'center', 
                gap: '1rem', 
                marginTop: '1rem',
                flexWrap: 'wrap'
              }}>
                {playerState.diceFlipStacks > 0 && (
                  <button
                    className="btn"
                    onMouseEnter={() => setIsHoveringFlipButton(true)}
                    onMouseLeave={() => setIsHoveringFlipButton(false)}
                    onClick={() => {
                      const flipAll = playerState.ownedRewards.includes('flip_all_double');
                      const forceAll = flipAll || currentBossType === 'flip_all';
                      const toFlip = forceAll ? new Set(Array.from({ length: totalDiceCount }, (_, i) => i)) : selectedIndices;
                      if (!forceAll && toFlip.size > 1 && !playerState.ownedRewards.includes('multi_flip')) {
                        setShowDiceModifyWarning(true);
                        setTimeout(() => setShowDiceModifyWarning(false), 2000);
                        return;
                      }
                      if (!forceAll && toFlip.size < 1) return;
                      const newDice = [...currentDice];
                      const newFaceIndices = [...diceFaceIndices];
                      toFlip.forEach(idx => {
                        const type = playerState.diceTypes[idx];
                        let faces = (stunnedIndices.has(idx) && type !== 'abyss_cursed')
                          ? [0,0,0,1,1,1]
                          : getDiceFaces(type);
                        if (faces) {
                          const i = newFaceIndices[idx] ?? 0;
                          const opp = 5 - i;
                          newDice[idx] = faces[opp];
                          newFaceIndices[idx] = opp;
                        } else if (newDice[idx] >= 1 && newDice[idx] <= 6) {
                          newDice[idx] = 7 - newDice[idx];
                          newFaceIndices[idx] = newDice[idx] - 1;
                        }
                      });
                      setCurrentDice(newDice);
                      setDiceFaceIndices(newFaceIndices);
                      setSelectedIndices(new Set());
                      setPlayerState(prev => ({ ...prev, diceFlipStacks: prev.diceFlipStacks - 1, usedFlipThisRound: true }));
                    }}
                    style={{
                      background: 'linear-gradient(to right, #8b5cf6, #7c3aed)',
                      padding: '0.75rem 1.5rem',
                      fontSize: '0.875rem'
                    }}
                  >
                    üîÑ ÏÑ†ÌÉùÌïú Ï£ºÏÇ¨ÏúÑ Îí§ÏßëÍ∏∞ ({playerState.diceFlipStacks}Ìöå ÎÇ®Ïùå)
                  </button>
                )}
              </div>
            )}

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
              <div className="score-preview">
                <div style={{ fontSize: '0.75rem', color: '#64748b', marginBottom: '0.5rem' }}>ÌòÑÏû¨ Ï°∞Ìï© ({totalDiceCount} Ï£ºÏÇ¨ÏúÑ)</div>
                <div style={{ fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '0.25rem', color: currentScore.isCursed ? '#6b7280' : '#6366f1' }}>
                  {currentScore.isCursed ? 'CURSED!' : currentScore.label}
                </div>
                <div style={{ fontSize: '0.875rem', color: '#64748b', marginBottom: '0.5rem' }}>{currentScore.labelKo}</div>
                <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#1e293b' }}>
                  {!currentScore.isCursed && (currentScore.enhancementBonus || 0) > 0 ? (
                    <>({currentScore.sum - currentScore.enhancementBonus}<span style={{ color: '#f59e0b' }}> +{currentScore.enhancementBonus}</span>) √ó{currentScore.multiplier}{currentScore.finalMultiplier > 1 && <span style={{ color: '#f59e0b' }}> √ó{currentScore.finalMultiplier}</span>}{' = '}<span style={{ fontSize: '1.5rem' }}>{currentScore.total}</span></>
                  ) : (
                    <>{currentScore.sum} √ó{currentScore.multiplier}{currentScore.finalMultiplier > 1 && <span style={{ color: '#f59e0b' }}> √ó{currentScore.finalMultiplier}</span>}{' = '}<span style={{ fontSize: '1.5rem' }}>{currentScore.total}</span></>
                  )}
                </div>
              </div>
            )}

            {allDiceStunned && !isMonsterDefeated && (
              <div style={{ textAlign: 'center', marginBottom: '1rem' }}>
                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#dc2626', marginBottom: '0.5rem' }}>Ìå®Î∞∞!</div>
                <div style={{ color: '#475569', marginBottom: '1rem' }}>‚ö† Î™®Îì† Ï£ºÏÇ¨ÏúÑÍ∞Ä Í∏∞Ï†àÌñàÏäµÎãàÎã§.</div>
                <button className="btn btn-attack" onClick={handleRestart}>Îã§Ïãú ÏãúÏûë</button>
              </div>
            )}

            {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
              <div className="rerolls-left">ÎÇ®ÏùÄ Î¶¨Î°§: {rerollsLeft}</div>
            )}

            <div className="controls">
              {!roundStarted && !isMonsterDefeated && !allDiceStunned && !showRewardSelection && !showVictory && !showEnhancementChoice && (
                <button className="btn btn-roll" onClick={handleInitialRoll}>Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞</button>
              )}
              {roundStarted && !showAttackResult && !showCounterattack && !allDiceStunned && (
                <>
                  <button className="btn btn-reroll" onClick={handleReroll} disabled={!canReroll}>
                    Î¶¨Î°§ ({rerollsLeft})
                  </button>
                  <button className="btn btn-attack" onClick={() => executeAttack(currentDice)} disabled={!canAttack}>
                    Í≥µÍ≤©!
                  </button>
                </>
              )}
            </div>

            {playerState.ownedRewards.length > 0 && (
              <div className="owned-rewards">
                {playerState.ownedRewards.map(rewardId => {
                  const reward = REWARDS.find(r => r.id === rewardId);
                  if (!reward) return null;
                  return (
                    <span key={rewardId} className="reward-badge" title={reward.descriptionKo}>
                      {reward.nameKo}
                    </span>
                  );
                })}
              </div>
            )}
          </main>

          <aside className="sidebar">
            <div className="guide-card">
              <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem' }}>Ï°±Î≥¥ Í∞ÄÏù¥Îìú</h2>
              {Object.entries(COMBINATIONS).map(([key, combo]) => {
                const boost = (playerState.combinationBoosts || {})[key] || 0;
                const mult = combo.multiplier + boost;
                return (
                  <div key={key} className="guide-item">
                    <span>{combo.labelKo}</span>
                    <span style={{ fontWeight: 'bold', color: boost > 0 ? '#fbbf24' : 'inherit' }}>√ó{mult}{boost > 0 && ' ‚¨Ü'}</span>
                  </div>
                );
              })}
              <div style={{ marginTop: '0.75rem', fontSize: '0.75rem', color: 'rgba(255,255,255,0.8)' }}>
                Îç∞ÎØ∏ÏßÄ = Ìï©Í≥Ñ √ó Î∞∞Ïàò √ó Î≥¥ÏÉÅ
              </div>
            </div>
          </aside>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Game />);
  </script>
</body>
</html>